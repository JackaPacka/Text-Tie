using System;
using System.Collections.Generic;
using System.Linq;
using Jungle.Nodes;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal class JungleExplorerView
    {
        // UI Elements
        private readonly IMGUIContainer _searchBar;
        private readonly VisualElement _scrollView;
        private readonly Label _headerLabel;
        private readonly VisualElement _headerIndicator;
        
        private List<ExplorerItem> _items;
        
        
        private string _lastSearch;
        private string _search;
        
        private class ExplorerItem
        {
            internal readonly string Title;
            internal readonly List<ExplorerItem> Children;
            internal readonly JungleExplorerItemView ContentView;
            
            internal ExplorerItem(string title)
            {
                Title = title;
                Children = new List<ExplorerItem>();
                ContentView = new JungleExplorerItemView(title);
            }

            internal ExplorerItem(JungleNode jungleNode)
            {
                Title = jungleNode.GetTitle();
                Children = null;
                ContentView = new JungleExplorerItemView(jungleNode);
            }
            
            internal ExplorerItem AddGetGroup(string name, out bool added)
            {
                if (Children.Any(group => group.Title == name))
                {
                    var group = Children.FirstOrDefault(group => group.Title == name);
                    added = false;
                    return group;
                }
                else
                {
                    var group = new ExplorerItem(name);
                    Children.Add(group);
                    added = true;
                    return group;
                }
            }
        }
        
        internal JungleExplorerView(VisualElement rootVisualElement)
        {
            var jungleNodeEntries = new List<ExplorerItem>();
            foreach (var type in TypeCache.GetTypesDerivedFrom(typeof(JungleNode)))
            {
                if (type.IsAbstract || type == typeof(StartNode))
                    continue;
                var instance = ScriptableObject.CreateInstance(type) as JungleNode;
                if (instance!.IsDeprecated())
                    continue;
                jungleNodeEntries.Add(new ExplorerItem(instance));
            }
            
            var browserRoot = new ExplorerItem("Explorer");
            foreach (var jungleNodeEntry in jungleNodeEntries)
            {
                // If the entry has no category, add it to the root group
                if (!jungleNodeEntry.ContentView.HasCategory())
                {
                    browserRoot.Children.Add(jungleNodeEntry);
                    continue;
                }
                
                var entryCategoryPath = jungleNodeEntry.ContentView.GetCategoryPath();
                var lastGroup = browserRoot;
                for (var i = 0; i < entryCategoryPath.Length; i++)
                {
                    var group = lastGroup.AddGetGroup(entryCategoryPath[i], out var added);
                    if (added)
                    {
                        group.ContentView.RegisterCallback<MouseDownEvent>(_ => OpenEntry(group));
                    }
                    if (i == entryCategoryPath.Length - 1)
                    {
                        group.Children.Add(jungleNodeEntry);
                        break;
                    }
                    lastGroup = group;
                }
            }
            
            _headerLabel = rootVisualElement.Q<Label>("browser-label");
            _headerIndicator = rootVisualElement.Q("browser-hover-indicator");
            if (_headerLabel != null)
            {
                _headerIndicator.style.display = DisplayStyle.None;
                _headerLabel?.RegisterCallback<MouseDownEvent>(_ => GoBack());
                _headerLabel?.RegisterCallback<MouseEnterEvent>(_ => _headerIndicator.style.display = DisplayStyle.Flex);
                _headerLabel?.RegisterCallback<MouseLeaveEvent>(_ => _headerIndicator.style.display = DisplayStyle.None);
            }
            
            _search = _lastSearch;
            _searchBar = rootVisualElement.Q<IMGUIContainer>("search-bar-container");
            if (_searchBar != null)
            {
                _searchBar.onGUIHandler = () =>
                {
                    GUILayout.BeginHorizontal();
                        GUILayout.Space(6f);
                        GUILayout.BeginVertical();
                            GUILayout.Space(4f);
                            _search = EditorGUILayout.TextField(_search, EditorStyles.toolbarSearchField);
                        GUILayout.EndVertical();
                        GUILayout.Space(6f);
                    GUILayout.EndHorizontal();
                    
                    if (_search != _lastSearch)
                    {
                        UpdateSearch(_search);
                        _lastSearch = _search;
                    }
                };
            }
            
            _scrollView = rootVisualElement.Q("browser-scroll-view");
            _items = new List<ExplorerItem>()
            {
                browserRoot
            };
            DrawBrowser();
            
            var isDarkTheme = EditorGUIUtility.isProSkin;
            rootVisualElement.AddToClassList(isDarkTheme ? "dark" : "light");
        }
        
        private void DrawBrowser()
        {
            _scrollView.Clear();
            var draw = _items.Last();
            foreach (var group in draw.Children)
            {
                _scrollView.Add(group.ContentView);
            }
            foreach (var jungleNodeEntry in draw.Children)
            {
                _scrollView.Add(jungleNodeEntry.ContentView);
            }
            _headerLabel.text = draw.Title;
        }
        
        private void UpdateSearch(string search)
        {
            if (string.IsNullOrEmpty(search))
            {
                _items = new List<ExplorerItem>(_items)
                {
                    _items[0]
                };
                DrawBrowser();
                return;
            }
            
            search = search.ToLower().Replace(" ", string.Empty);
            _scrollView.Clear();
            foreach (var jungleNodeType in TypeCache.GetTypesDerivedFrom(typeof(JungleNode)))
            {
                if (jungleNodeType.IsAbstract || jungleNodeType == typeof(StartNode))
                    continue;
                var jungleNode = ScriptableObject.CreateInstance(jungleNodeType) as JungleNode;
                if (jungleNode!.IsDeprecated())
                    continue;
                if (!jungleNode.GetTitle().ToLower().Replace(" ", string.Empty).Contains(search))
                    continue;
                _scrollView.Add(new JungleExplorerItemView(jungleNode));
            }
            //_headerLabel.text = "Search";
            _headerLabel.text = $"{_scrollView.childCount} result" + (_scrollView.childCount != 1 ? "s" : string.Empty);
        }
        
        private void OpenEntry(ExplorerItem item)
        {
            _items.Add(item);
            DrawBrowser();
        }
        
        private void GoBack()
        {
            if (!string.IsNullOrEmpty(_search))
            {
                _search = string.Empty;
                UpdateSearch(string.Empty);
                return;
            }
            
            if (_items.Count <= 1)
            {
                return;
            }
            _items.RemoveAt(_items.Count - 1);
            DrawBrowser();
        }
    }
    
    internal class JungleExplorerItemView : VisualElement
    {
        private const string UI_FILE_PATH = "JungleUI/JungleExplorerItemView";
        private const string HOVER_CLASS_LIST = "hover";
        private const string SELECTED_CLASS_LIST = "selected";
            
        internal Action<JungleNode> OnSelected;
            
        private readonly JungleNode _jungleNode;
        private bool _hovering;
        private bool _selected;
            
        internal JungleExplorerItemView(JungleNode jungleNode)
        {
            CreateVisualTree();
            _jungleNode = jungleNode;
                
            this.Q("group-labels").style.display = DisplayStyle.None;
            this.Q("entry-labels").style.display = DisplayStyle.Flex;
                
            // MAKE THIS THE DEFAULT ICON IF NO ICON WAS SET!
            this.Q("icon").style.backgroundImage = new StyleBackground(jungleNode.GetIcon() as Texture2D);
            this.Q<Label>("entry-title").text = jungleNode.GetTitle();
            this.Q<Label>("entry-description").text = jungleNode.GetDescription();
                
            RegisterHoverCallbacks();
            RegisterCallback<MouseDownEvent>(_ => SetSelectedTheme(true));
        }
            
        internal JungleExplorerItemView(string groupTitle)
        {
            CreateVisualTree();
                
            this.Q("entry-labels").style.display = DisplayStyle.None;
            this.Q("group-labels").style.display = DisplayStyle.Flex;
                
            var folderIcon = EditorGUIUtility.IconContent
            (
                EditorGUIUtility.isProSkin
                    ? "d_Folder Icon"
                    : "Folder Icon"
            ).image as Texture2D;
            this.Q("icon").style.backgroundImage = new StyleBackground(folderIcon);
            this.Q<Label>("group-title").text = groupTitle;
                
            RegisterHoverCallbacks();
        }
            
        private void CreateVisualTree()
        {
            var uiFile = AssetDatabase.GetAssetPath(Resources.Load(UI_FILE_PATH));
            var visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(uiFile);
            visualTree.CloneTree(this);
            
        }
            
        private void RegisterHoverCallbacks()
        {
            SetHoverTheme(false);
            RegisterCallback<MouseEnterEvent>(_ => SetHoverTheme(true));
            RegisterCallback<MouseLeaveEvent>(_ => SetHoverTheme(false));
        }
            
        private void SetHoverTheme(bool hovering)
        {
            if (_selected)
                return;
                
            if (hovering)
            {
                AddToClassList(HOVER_CLASS_LIST);
            }
            else
            {
                RemoveFromClassList(HOVER_CLASS_LIST);
            }
            _hovering = hovering;
        }
        
        private void SetSelectedTheme(bool selected)
        {
            if (selected && _hovering)
                SetHoverTheme(false);
                
            if (selected)
            {
                AddToClassList(SELECTED_CLASS_LIST);

                if (_selected != selected)
                {
                    OnSelected?.Invoke(_jungleNode);
                    JungleBrowser.SetContext(_jungleNode.GetType());
                    JungleBrowser.OnDragCancelled += OnDragCancelled;
                }
            }
            else
            {
                RemoveFromClassList(SELECTED_CLASS_LIST);
            }
            _selected = selected;
        }
        
        private void OnDragCancelled()
        {
            SetSelectedTheme(false);
            JungleBrowser.OnDragCancelled -= OnDragCancelled;
        }
        
        internal string[] GetCategoryPath()
        {
            return _jungleNode.GetCategory().Split('/');
        }
            
        internal bool HasCategory() 
        {
            return !string.IsNullOrEmpty(_jungleNode.GetCategory());
        }
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Jungle.Nodes;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal class JungleGraphView : GraphView
    {
        #region Properties
        
        internal List<JungleNodeView> SelectedNodeViews
        {
            get;
            private set;
        } = new();
        
        private readonly JungleRectangleSelector _rectangleSelector;
        private JungleTree _jungleTree;
        private Vector2 _mousePosition;
        private JungleNodeView _cursorShadow;
        private List<JungleNodeView> _jungleNodeViews;
        private bool _needToSaveCameraPositionAndZoom;
        private Vector3 _lastViewPosition;
        private Vector3 _lastViewScale;
        
        public override List<UnityEditor.Experimental.GraphView.Port> GetCompatiblePorts
        (
            UnityEditor.Experimental.GraphView.Port selected,
            NodeAdapter _
        )
        {
            // If the port type is null, this means that the node has some kind of issue internally.
            // It is safest to just not allow any connections until the problem is fixed
            if (selected.portType == typeof(Port.Error))
            {
                return new List<UnityEditor.Experimental.GraphView.Port>();
            }
            // Otherwise the compatible port must not be the same connection direction and the same
            // connection type
            var compatible = ports.ToList().Where
            (
                other => other.direction != selected.direction 
                         && other.node != selected.node 
                         && (other.portType == selected.portType || other.portType == typeof(Port.NA))
            );
            return compatible.ToList();
        }
        
        public new class UxmlFactory : UxmlFactory<JungleGraphView, UxmlTraits> { }

        #endregion
        
        public JungleGraphView()
        {
            Insert(0, new GridBackground());
            
            const float MINIMUM_ZOOM_SCALE = 0.35f;
            const float MAXIMUM_ZOOM_SCALE = 1.75f;
            SetupZoom
            (
                MINIMUM_ZOOM_SCALE,
                MAXIMUM_ZOOM_SCALE,
                ContentZoomer.DefaultScaleStep,
                ContentZoomer.DefaultReferenceScale
            );
            
            this.AddManipulator(new ContentDragger());
            this.AddManipulator(new SelectionDragger());
            
            _rectangleSelector = new JungleRectangleSelector();
            SetRectangleSelectionState(true);
            
            RegisterCallback<MouseUpEvent>(mouseEvent =>
            {
                if (mouseEvent.button == 0 && _cursorShadow != null)
                {
                    _jungleTree.Manifest.UpdateNodeMetaData(_cursorShadow.Node, _cursorShadow.GetPosition().position);
                    _cursorShadow = null;
                }
                else if (mouseEvent.button == 2)
                    SaveGraphViewCameraPositionAndZoom();
            });
            RegisterCallback<WheelEvent>(_ =>
            {
                SaveGraphViewCameraPositionAndZoom();
            });
            RegisterCallback<MouseMoveEvent>(mouseEvent =>
            {
                _mousePosition =
                    contentViewContainer.WorldToLocal(new Rect(mouseEvent.mousePosition, Vector2.one).position);
            });
            
            AddToClassList
            (
                EditorGUIUtility.isProSkin 
                    ? "dark" 
                    : "light"
            );
            
            if (JunglePreferencesUtility.StickyNoteFont)
                AddToClassList("handWrittenFont");
            
            Undo.undoRedoPerformed += DrawGraphView;
        }
        
        internal void SetupGraphView(JungleTree jungleTree)
        {
            // Set the view position and scale
            var manifest = jungleTree.Manifest;
            _lastViewPosition = manifest.ViewPosition;
            _lastViewScale = manifest.ViewScale;
            
            // If the view scale is zero, set it to one
            if (_lastViewScale == Vector3.zero)
                _lastViewScale = Vector3.one;
            
            viewTransform.position = _lastViewPosition;
            viewTransform.scale = _lastViewScale;
            
            // Cache reference and draw the graph view
            _jungleTree = jungleTree;
            DrawGraphView();
        }
        
        internal void PerformUpdate()
        {
            if (_cursorShadow != null)
                _cursorShadow.SetPosition(new Rect(_mousePosition, Vector2.one));
            
            if (_needToSaveCameraPositionAndZoom)
            {
                SaveGraphViewCameraPositionAndZoom();
                _needToSaveCameraPositionAndZoom = false;
            }
        }
        
        internal void AddNodeAndFollowCursor(Type nodeType)
        {
            var node = _jungleTree.AddNode(nodeType, _mousePosition);
            var nodeView = new JungleNodeView(node);
            _jungleNodeViews.Add(nodeView);
            AddElement(nodeView);
            
            _cursorShadow = nodeView;
            nodeView.Select(this, false);
        }
        
        internal void SetRectangleSelectionState(bool state)
        {
            if (state)
                this.AddManipulator(_rectangleSelector);
            else
                this.RemoveManipulator(_rectangleSelector);
        }
        
        private void DrawGraphView()
        { 
            graphViewChanged -= GraphViewChangedCallback;
            DeleteElements(graphElements);
            graphViewChanged += GraphViewChangedCallback;
            
            var manifest = _jungleTree.Manifest;
            var viewPosition = manifest.ViewPosition;
            var viewScale = manifest.ViewScale;
            if (viewPosition != _lastViewPosition)
            {
                viewTransform.position = viewPosition;
                _lastViewPosition = viewPosition;
            }
            if (viewScale != _lastViewScale)
            {
                viewTransform.scale = viewScale;
                _lastViewScale = viewScale;
            }
            
            _jungleNodeViews = new List<JungleNodeView>();
            
            // Draw all node views
            foreach (var node in _jungleTree.Nodes)
            {
                var nodeView = new JungleNodeView(node);
                _jungleNodeViews.Add(nodeView);
                nodeView.RefreshPortContainers();
                AddElement(nodeView);
            }
            
            // Draw all connections
            foreach (var nodeView in _jungleNodeViews)
            {
                if (nodeView.OutputPortViews == null)
                    continue;

                for (var i = 0; i < nodeView.OutputPortViews.Count; i++)
                {
                    if (i >= nodeView.Node.OutputPorts.Length)
                        break;
                    var outputPortView = nodeView.OutputPortViews[i];
                    var outputPort = nodeView.Node.OutputPorts[i];
                    foreach (var connection in outputPort.Connections)
                    {
                        var connectionView = _jungleNodeViews.FirstOrDefault(node => node.Node == connection);
                        if (connectionView == null)
                            continue;
                        AddElement(connectionView.InputPortView.ConnectTo(outputPortView));
                    }
                }
            }
            
            // Draw all note views
            foreach (var stickyNote in _jungleTree.Manifest.StickyNoteManifest)
            {
                TryAddStickyNote(new JungleStickyNoteView(stickyNote.Uid, _jungleTree, this));
            }
        }
        
        private void SaveGraphViewCameraPositionAndZoom()
        {
            var currentViewPosition = viewTransform.position;
            if (currentViewPosition != _lastViewPosition)
            {
                _jungleTree.Manifest.ViewPosition = viewTransform.position;
                _lastViewPosition = currentViewPosition;
            }
            
            var currentViewScale = viewTransform.scale;
            if (currentViewScale != _lastViewScale)
            {
                _jungleTree.Manifest.ViewScale = viewTransform.scale;
                _lastViewScale = currentViewScale;
            }
        }
        
        private GraphViewChange GraphViewChangedCallback(GraphViewChange changes)
        {
            if (changes.elementsToRemove != null)
            {
                // Remove start node from the list of nodes to remove (If needed)
                changes.elementsToRemove.RemoveAll
                (
                    element => element is JungleNodeView { Node: StartNode }
                );
                
                var nodesToRemove = new List<JungleNode>();
                foreach (var element in changes.elementsToRemove)
                {
                    if (element is JungleNodeView nodeView)
                    {
                        if (nodeView.Node is StartNode)
                            continue;
                        nodesToRemove.Add(nodeView.Node);
                    }
                    else if (element is Edge edge)
                    {
                        if (edge.output.node is not JungleNodeView nodeViewA ||
                            edge.input.node is not JungleNodeView nodeViewB) continue;
                        
                        var portIndex = (byte)Array.IndexOf(nodeViewA.OutputPortViews.ToArray(), edge.output);
                        _jungleTree.DisconnectNodes(nodeViewA.Node, nodeViewB.Node, portIndex);
                    }
                    else if (element is JungleStickyNoteView stickyNoteView)
                    {
                        Undo.RecordObject(_jungleTree.Manifest, $"Deleted note in {_jungleTree.name}");
                        _jungleTree.Manifest.RemoveStickyNoteMetaData(stickyNoteView.viewDataKey);
                    }
                    
                    RemoveElement(element);
                }

                if (nodesToRemove.Count > 0)
                {
                    _jungleTree.RemoveNodes(nodesToRemove.ToArray());
                    JungleEditor.Instance.UpdateGraphLabels();
                }
            }
            
            if (changes.movedElements != null)
            {
                foreach (var element in changes.movedElements)
                {
                    if (element is JungleNodeView nodeView)
                    {
                        var node = nodeView.Node;
                        var position = nodeView.GetPosition();
                        Undo.RecordObject(_jungleTree.Manifest, $"Set {node.name}'s position");
                        node.JungleTree.Manifest.UpdateNodeMetaData
                        (
                            node,
                            new Vector2(position.xMin, position.yMin)
                        );
                    }
                    else if (element is JungleStickyNoteView stickyNoteView)
                    {
                        var rect = stickyNoteView.GetPosition();
                        Undo.RecordObject(_jungleTree.Manifest, $"Set a notes position in {_jungleTree.name}");
                        _jungleTree.Manifest.UpdateStickyNoteGraphPosition
                        (
                            stickyNoteView.viewDataKey,
                            rect.position
                        );
                    }
                }
            }
            
            if (changes.edgesToCreate != null)
            {
                foreach (var edge in new List<Edge>(changes.edgesToCreate))
                {
                    if (edge.output.node is not JungleNodeView nodeViewA ||
                        edge.input.node is not JungleNodeView nodeViewB) continue;
                    
                    var portIndex = (byte)Array.IndexOf(nodeViewA.OutputPortViews.ToArray(), edge.output);
                    _jungleTree.ConnectNodes(nodeViewA.Node, nodeViewB.Node, portIndex);
                }
            }
            
            return changes;
        }
        
        public override void AddToSelection(ISelectable selectable)
        {
            if (selectable is JungleNodeView nodeView)
            {
                SelectedNodeViews ??= new List<JungleNodeView>();
                SelectedNodeViews.Add(nodeView);
                
                JungleEditor.Instance.Inspect(nodeView.Node);
            }
            base.AddToSelection(selectable);
        }
        
        public override void RemoveFromSelection(ISelectable selectable)
        {
            if (selectable is JungleNodeView nodeView)
            {
                SelectedNodeViews ??= new List<JungleNodeView>();
                SelectedNodeViews.Remove(nodeView);
                
                // If there are no more nodes selected, inspect nothing
                if (SelectedNodeViews.Count == 0)
                    JungleEditor.Instance.InspectNothing();
                
                // If the node being inspected is being removed from selection, inspect the next node
                else if (JungleEditor.Instance.InspectorTarget == nodeView.Node)
                    JungleEditor.Instance.Inspect(SelectedNodeViews.Last().Node);
            }
            base.RemoveFromSelection(selectable);
        }
        
        public override void ClearSelection()
        {
            SelectedNodeViews = new List<JungleNodeView>();
            JungleEditor.Instance.InspectNothing();
            base.ClearSelection();
        }
        
        public override void BuildContextualMenu(ContextualMenuPopulateEvent context)
        {
            context.menu.AppendAction("Select All\tCtrl+A", _ =>
            {
                PerformSelectAll();
            });
            
            context.menu.AppendSeparator();
            var onlyStartNodeSelected = SelectedNodeViews.Count == 1 && SelectedNodeViews[0].Node is StartNode;
            var allowCopyAction = !onlyStartNodeSelected && SelectedNodeViews.Count > 0;
            context.menu.AppendAction("Copy\tCtrl+C", _ =>
            {
                PerformCopy();
            }, allowCopyAction ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
            
            var allowPasteAction = !onlyStartNodeSelected && JungleClipboardUtility.HasClipboard();
            context.menu.AppendAction("Paste\tCtrl+V", _ =>
            {
                PerformPaste();
            }, allowPasteAction ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
            
            var allowDuplicateAction = !onlyStartNodeSelected && SelectedNodeViews.Count > 0;
            context.menu.AppendAction("Duplicate\tCtrl+D", _ =>
            {
                PerformDuplicate();
            }, allowDuplicateAction ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);

            var allowDeleteAction = !onlyStartNodeSelected && selection.Count > 0;
            context.menu.AppendAction("Delete\tDel", _ =>
            {
                DeleteSelection();
            }, allowDeleteAction ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
            
            context.menu.AppendSeparator();
            context.menu.AppendAction("Add Note\tL Shift+S", _ =>
            {
                PerformAddNote();
            });
            
            
            // Graph view specific actions
            if (context.target is JungleGraphView)
            {
                context.menu.AppendSeparator();
                context.menu.AppendAction("Recenter View\tO", _ =>
                {
                    viewTransform.position = Vector3.zero;
                    viewTransform.scale = Vector3.one;
                    SaveGraphViewCameraPositionAndZoom();
                });
                context.menu.AppendAction("Preferences", _ =>
                {
                    JunglePreferences.OpenWindow();
                });
                context.menu.AppendSeparator();
                context.menu.AppendAction("View Docs", _ =>
                {
                    Application.OpenURL("https://junglesequencer.com/docs/welcome");
                });
            }
            // Node view specific actions
            else if (context.target is JungleNodeView nodeView)
            {
                context.menu.AppendSeparator();
                context.menu.AppendAction("Edit Script...", _ =>
                {
                    var script = MonoScript.FromScriptableObject(nodeView.Node);
                    AssetDatabase.OpenAsset(script);
                });
            }
            // Sticky note view specific actions
            else if (context.target is JungleStickyNoteView stickyNoteView)
            {
                context.menu.AppendSeparator();
                var isYellowTheme = stickyNoteView.Theme == "yellow";
                context.menu.AppendAction("Theme/Yellow", _ =>
                {
                    stickyNoteView.SetTheme("yellow");
                }, isYellowTheme ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
                var isGreenTheme = stickyNoteView.Theme == "green";
                context.menu.AppendAction("Theme/Green", _ =>
                {
                    stickyNoteView.SetTheme("green");
                }, isGreenTheme ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
                var isBlueTheme = stickyNoteView.Theme == "blue";
                context.menu.AppendAction("Theme/Blue", _ =>
                {
                    stickyNoteView.SetTheme("blue");
                }, isBlueTheme ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
                var isPinkTheme = stickyNoteView.Theme == "pink";
                context.menu.AppendAction("Theme/Pink", _ =>
                {
                    stickyNoteView.SetTheme("pink");
                }, isPinkTheme ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
                var isGreyTheme = stickyNoteView.Theme == "grey";
                context.menu.AppendAction("Theme/Grey", _ =>
                {
                    stickyNoteView.SetTheme("grey");
                }, isGreyTheme ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
                var isLocked = stickyNoteView.IsLocked;
                context.menu.AppendAction("Lock", _ =>
                {
                    stickyNoteView.SetLockState(!isLocked);
                }, isLocked ? DropdownMenuAction.Status.Checked : DropdownMenuAction.Status.Normal);
            }
        }
        
        protected override void ExecuteDefaultAction(EventBase @event)
        {
            if (@event is KeyDownEvent {ctrlKey: true, keyCode: KeyCode.A})
                PerformSelectAll();
            
            else if (@event is KeyDownEvent {ctrlKey: true, keyCode: KeyCode.C})
                PerformCopy();
            
            else if (@event is KeyDownEvent {ctrlKey: true, keyCode: KeyCode.V})
                PerformPaste();
            
            else if (@event is KeyDownEvent {ctrlKey: true, keyCode: KeyCode.D})
                PerformDuplicate();
            
            else if (@event is KeyDownEvent {shiftKey: true, keyCode: KeyCode.S})
                PerformAddNote();
            
            // These are a work around for saving the camera position and zoom -----------------------------------------
            else if (@event is KeyDownEvent {keyCode: KeyCode.A})
                _needToSaveCameraPositionAndZoom = true;
            else if (@event is KeyDownEvent {keyCode: KeyCode.O})
                _needToSaveCameraPositionAndZoom = true;
            else if (@event is KeyDownEvent {keyCode: KeyCode.F})
                _needToSaveCameraPositionAndZoom = true;
            else if (@event is KeyDownEvent {keyCode: KeyCode.LeftBracket})
                _needToSaveCameraPositionAndZoom = true;
            else if (@event is KeyDownEvent {keyCode: KeyCode.RightBracket})
                _needToSaveCameraPositionAndZoom = true;
            // These are a work around for saving the camera position and zoom -----------------------------------------
            
            base.ExecuteDefaultAction(@event);
        }
        
        private void PerformCopy()
        {
            JungleClipboardUtility.SetClipboard(SelectedNodeViews.Select(view => view.Node).ToArray());
        }
        
        private void PerformPaste()
        {
            var clipboard = JungleClipboardUtility.GetClipboard();
            if (clipboard == null || clipboard.Length == 0)
                return;
            var mousePositionOffset = _mousePosition - clipboard[0].GraphPosition;
            var pastedNodes = clipboard.Select
            (
                clipboardItem => clipboardItem.Node
            ).ToArray();
            var nodePositions = clipboard.Select
            (
                clipboardItem => clipboardItem.GraphPosition + mousePositionOffset
            ).ToArray();
            var newNodes = _jungleTree.AddNodes(pastedNodes, nodePositions);
            
            ClearSelection();
            foreach (var node in newNodes)
            {
                var nodeView = new JungleNodeView(node);
                AddElement(nodeView);
                AddToSelection(nodeView);
            }
        }
        
        private void PerformDuplicate()
        {
            JungleClipboardUtility.SetClipboard(SelectedNodeViews.Select(view => view.Node).ToArray());
            var clipboard = JungleClipboardUtility.GetClipboard();
            if (clipboard == null || clipboard.Length == 0)
                return;
            var pastedNodes = clipboard.Select
            (
                clipboardItem => clipboardItem.Node
            ).ToArray();
            var nodePositions = clipboard.Select
            (
                clipboardItem => clipboardItem.GraphPosition + Vector2.one * 25f
            ).ToArray();
            var newNodes = _jungleTree.AddNodes(pastedNodes, nodePositions);
            
            ClearSelection();
            foreach (var node in newNodes)
            {
                var nodeView = new JungleNodeView(node);
                AddElement(nodeView);
                AddToSelection(nodeView);
            }
            
            JungleClipboardUtility.ClearClipboard();
        }
        
        private void PerformSelectAll()
        {
            nodes.ToList().ForEach(AddToSelection);
        }

        private void PerformAddNote()
        {
            if (selection.Count > 0)
            {
                PerformAddNoteGroup();
                return;
            }
            
            Undo.RecordObject(_jungleTree.Manifest, $"Added a note to {_jungleTree.name}");
            var metaData = _jungleTree.Manifest.CreateStickyNoteMetaData
            (
                _mousePosition,
                new Vector2(200f, 200f),
                string.Empty,
                "yellow"
            );
            TryAddStickyNote(new JungleStickyNoteView(metaData.Uid, _jungleTree, this));
        }
        
        private void PerformAddNoteGroup()
        {
            var selectedNodeViews = selection.OfType<JungleNodeView>().ToList();
            if (selectedNodeViews.Count == 0)
                return;
            
            var stickyNotePosition = new Rect(selectedNodeViews[0].GetPosition().position, Vector2.zero);
            foreach (var nodeView in selectedNodeViews)
            {
                var nodePosition = nodeView.GetPosition();
                stickyNotePosition.xMin = Mathf.Min(stickyNotePosition.xMin, nodePosition.xMin);
                stickyNotePosition.yMin = Mathf.Min(stickyNotePosition.yMin, nodePosition.yMin);
                stickyNotePosition.xMax = Mathf.Max(stickyNotePosition.xMax, nodePosition.xMax);
                stickyNotePosition.yMax = Mathf.Max(stickyNotePosition.yMax, nodePosition.yMax);
            }
            stickyNotePosition.xMin -= 12.5f;
            stickyNotePosition.yMin -= 50f;
            stickyNotePosition.xMax += 12.5f;
            stickyNotePosition.yMax += 12.5f;
            
            Undo.RecordObject(_jungleTree.Manifest, $"Added a note group to {_jungleTree.name}");
            var metaData = _jungleTree.Manifest.CreateStickyNoteMetaData
            (
                stickyNotePosition.position,
                stickyNotePosition.size,
                "...",
                "grey"
            );
            TryAddStickyNote(new JungleStickyNoteView(metaData.Uid, _jungleTree, this));
        }
        
        private void TryAddStickyNote(JungleStickyNoteView noteView)
        {
            var stickyNoteLayer = contentViewContainer.Q<Layer>("sticky-note-layer");
            if (stickyNoteLayer == null)
            {
                stickyNoteLayer = new Layer
                {
                    name = "sticky-note-group"
                };
                contentViewContainer.Insert(0, stickyNoteLayer);
            }
            stickyNoteLayer.Add(noteView);
        }
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal class JungleNodeView : Node
    {
        #region Properties

        private const int MAX_TITLE_LENGTH = 50;
        private const int MAX_TOOLTIP_LENGTH = 250;
        private const float MINIMUM_GLOW_TIME_S = 1.25f; 
        
        private readonly List<string> BANNED_ICON_NAMES = new()
        {
            "ScriptableObject Icon",
            "d_ScriptableObject Icon"
        };
        
        private static readonly string JungleNodeViewUxmlFilePath = 
            AssetDatabase.GetAssetPath(Resources.Load("JungleUI/JungleNodeView"));
        
        private readonly Color _warningIconNotHoveredColor = new Color(0.85f, 0.85f, 0.85f);
        
        public sealed override string title
        {
            get => base.title;
            set => base.title = value;
        }
        
        internal readonly JungleNode Node;
        internal readonly JungleNodeManifestItem NodeManifestItem;
        internal UnityEditor.Experimental.GraphView.Port InputPortView;
        internal List<UnityEditor.Experimental.GraphView.Port> OutputPortViews;
        
        private VisualElement _accentElement;
        private VisualElement _iconElement;
        private VisualElement _glowElement;
        private VisualElement _warningElement;
        private Label _detailsLabel;
        private float _glowStartTime;
        
        private float GetGlowTimeSeconds()
        {
            return (float)EditorApplication.timeSinceStartup - _glowStartTime;
        }
        
        private string GetTextColor()
        {
            return EditorGUIUtility.isProSkin 
                ? "#D4D4D4" 
                : "#222222";
        }

        private Color GetPortColorForType(Type type)
        {
            if (type == typeof(Port.None) || type == typeof(Port.NA))
            {
                return JunglePreferencesUtility.NonePortColor;
            }
            if (type.IsValueType && !type.IsPrimitive)
            {
                return JunglePreferencesUtility.StructPortColor;
            }
            if
            (
                typeof(MonoBehaviour).IsAssignableFrom(type) || 
                typeof(Component).IsAssignableFrom(type) ||
                type == typeof(GameObject)
            )
            {
                return JunglePreferencesUtility.UnityMonoBehaviourPortColor;
            }
            if (typeof(ScriptableObject).IsAssignableFrom(type))
            {
                return JunglePreferencesUtility.UnityScriptableObjectPortColor;
            }
            return JunglePreferencesUtility.PrimitivePortColor;
        }
        
        #endregion
        
        internal JungleNodeView(JungleNode node) : base(JungleNodeViewUxmlFilePath)
        {
            if (node == null)
                return;
            
            Node = node;
            NodeManifestItem = node.JungleTree.Manifest.TryGetNodeMetaData(node);
            
            viewDataKey = NodeManifestItem.Uid;
            SetInitialPosition(NodeManifestItem);
            
            SetTitleAndTooltip
            (
                Node.GetTitle(),
                Node.GetDescription()
            );
            
            TryGetAllUxmlElements();
            SetTheme();

            if (_iconElement != null)
            {
                var iconImage = Node.GetIcon();
                if (iconImage != null)
                {
                    _iconElement.style.backgroundImage = new StyleBackground(iconImage as Texture2D);
                    _iconElement.style.display = BANNED_ICON_NAMES.Any(n => n == iconImage.name)
                        ? DisplayStyle.None 
                        : DisplayStyle.Flex;
                }
            }
            
            if (_accentElement != null)
                _accentElement.style.backgroundColor = Node.GetColor();
            
            if (_glowElement != null)
                _glowElement.style.display = DisplayStyle.None;

            if (_warningElement != null)
            {
                _warningElement.style.display = DisplayStyle.None;
                _warningElement.style.unityBackgroundImageTintColor = _warningIconNotHoveredColor;
                _warningElement.RegisterCallback<MouseEnterEvent>(_ =>
                {
                    _warningElement.style.unityBackgroundImageTintColor = Color.white;
                });
                _warningElement.RegisterCallback<MouseLeaveEvent>(_ =>
                {
                    _warningElement.style.unityBackgroundImageTintColor = _warningIconNotHoveredColor;
                });
                _warningElement.RegisterCallback<MouseDownEvent>(_ =>
                {
                    JungleValidatorUtility.PerformSoftValidationPass();
                    JungleValidator.OpenWindow(Node.Uid);
                });
            }
            
            if (_detailsLabel != null)
            {
                var details = Node.GetDetails();
                if (!string.IsNullOrEmpty(details))
                {
                    _detailsLabel.text = details;
                    _detailsLabel.style.display = DisplayStyle.Flex;
                }
                else _detailsLabel.style.display = DisplayStyle.None;
            }
            
            RefreshPortContainers();
            
            Node.OnValidated += ValidationCallback;
            Node.Validate();
        }
        
        private void TryGetAllUxmlElements()
        {
            _iconElement = mainContainer.Q("icon-image");
            if (_iconElement == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>Editor</b>] " +
                    "Failed to find \"icon-image\" element in the Jungle Node View UXML file."
                );
            }
            
            _accentElement = mainContainer.Q("accent");
            if (_accentElement == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>Editor</b>] " +
                    "Failed to find \"accent\" element in the Jungle Node View UXML file."
                );
            }
            
            _detailsLabel = mainContainer.Q<Label>("details");
            if (_detailsLabel == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>Editor</b>] " +
                    "Failed to find \"details\" element in the Jungle Node View UXML file."
                );
            }
            
            _glowElement = mainContainer.Q("glow");
            if (_glowElement == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>Editor</b>] " +
                    "Failed to find \"glow\" element in the Jungle Node View UXML file."
                );
            }
            
            _warningElement = mainContainer.Q("warning-icon");
            if (_warningElement == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>Editor</b>] " +
                    "Failed to find \"warning-icon\" element in the Jungle Node View UXML file."
                );
            }
        }
        
        private void SetInitialPosition(JungleNodeManifestItem manifestItem)
        {
            style.left = manifestItem.GraphPosition.x;
            style.top = manifestItem.GraphPosition.y;
        }
        
        private void SetTitleAndTooltip(string title, string tooltip)
        {
            this.title = JungleEditor.ShortenString(title, MAX_TITLE_LENGTH);
            this.tooltip = JungleEditor.ShortenString(tooltip, MAX_TOOLTIP_LENGTH);
        }
        
        private void SetTheme()
        {
            AddToClassList
            (
                EditorGUIUtility.isProSkin
                    ? "dark"
                    : "light"
            );
        }
        
        private void ValidationCallback(bool hasIssues)
        {
            if (hasIssues)
            {
                _warningElement.style.display = DisplayStyle.Flex;
            }
            else
            {
                _warningElement.style.display = DisplayStyle.None;
            }
            
            // Update details label
            var details = Node.GetDetails();
            if (!string.IsNullOrEmpty(details))
            {
                _detailsLabel.text = details;
                _detailsLabel.style.display = DisplayStyle.Flex;
            }
            else
            {
                _detailsLabel.text = string.Empty;
                _detailsLabel.style.display = DisplayStyle.None;
            }
        }
        
        internal void RefreshPortContainers()
        {
            RefreshInputPortView();
            RefreshOutputPortViews();
        }
        
        private void RefreshInputPortView()
        {
            if (Node == null) 
                return;
            var inputPort = Node.GetInputPortInfo();
            if (inputPort.Name == null || inputPort.Type == null)
            {
                inputContainer.Clear();
                return;
            }

            var portCapacity = Node is GenericNode
                ? UnityEditor.Experimental.GraphView.Port.Capacity.Single
                : UnityEditor.Experimental.GraphView.Port.Capacity.Multi;
            
            InputPortView = InstantiatePort
            (
                Orientation.Horizontal,
                Direction.Input,
                portCapacity,
                inputPort.Type
            );
            var portType = inputPort.Type != typeof(Port.NA)
                ? JungleEditor.ShortenString
                (
                    inputPort.Type != typeof(Port.Error) ? inputPort.Type.Name : nameof(Port.Error).ToUpper(),
                    24
                )
                : "N/a";
            var portTitle = JungleEditor.ShortenString(inputPort.Name, 30);
            InputPortView.portName = 
                $"<color={GetTextColor()}><b><size=10><i>({portType})</i></size> {portTitle}</b></color>";
            InputPortView.portColor = GetPortColorForType(inputPort.Type);
            InputPortView.SetEnabled
            (
                InputPortView.portType != typeof(Port.NA) && InputPortView.portType != typeof(Port.Error)
            );
            
            inputContainer.Clear();
            inputContainer.Add(InputPortView);
        }
        
        private void RefreshOutputPortViews()
        {
            if (Node == null) return;
            var outputPorts = Node.GetOutputPortsInfo();
            if (outputPorts == null || outputPorts.Length == 0)
            {
                outputContainer.Clear();
                return;
            }
            
            OutputPortViews = new List<UnityEditor.Experimental.GraphView.Port>();
            foreach (var outputPort in outputPorts)
            {
                var newPortView = InstantiatePort
                (
                    Orientation.Horizontal, 
                    Direction.Output, 
                    UnityEditor.Experimental.GraphView.Port.Capacity.Multi,
                    outputPort.Type
                );
                var portType = outputPort.Type != typeof(Port.NA)
                    ? JungleEditor.ShortenString
                    (
                        outputPort.Type != typeof(Port.Error) ? outputPort.Type.Name : nameof(Port.Error).ToUpper(),
                        16
                    )
                    : "N/a";
                var portTitle = JungleEditor.ShortenString(outputPort.Name, 30);
                newPortView.portName = 
                    $"<color={GetTextColor()}><b>{portTitle} <size=10><i>({portType})</i></size></b></color>";
                newPortView.portColor = GetPortColorForType(outputPort.Type);
                newPortView.SetEnabled
                (
                    newPortView.portType != typeof(Port.NA) && newPortView.portType != typeof(Port.Error)
                );
                
                OutputPortViews.Add(newPortView);
            }
            
            outputContainer.Clear();
            OutputPortViews.ToList().ForEach(view => outputContainer.Add(view));
        }
        
        internal void UpdateActiveGlow()
        {
            if (Node == null)
                return;
            
            if (!Application.isPlaying && _glowStartTime != 0f)
            {
                _glowElement.style.display = DisplayStyle.None;
                _glowStartTime = 0f;
            }
            
            if (_glowStartTime == 0f && Node.IsRunning)
            {
                _glowElement.style.display = DisplayStyle.Flex;
                _glowStartTime = (float)EditorApplication.timeSinceStartup;
            }
            
            if (_glowStartTime != 0f && !Node.IsRunning && GetGlowTimeSeconds() > MINIMUM_GLOW_TIME_S)
            {
                _glowElement.style.display = DisplayStyle.None;
                _glowStartTime = 0f;
            }
        }
        
        // Overridden to remove "Disconnect all" action
        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt) { }
    }
}
﻿// --------------------------------------------------------------------------------------------------
// NOTE - This is a modified version of the RectangleSelector class from the Unity GraphView package.
// --------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal class JungleRectangleSelector : MouseManipulator
    {
        #region Properties
        
        private readonly RectangleSelect _rectangle;
        private bool _active;
        
        private static Material _lineMaterial;
        private static readonly int SrcBlend = Shader.PropertyToID("_SrcBlend");
        private static readonly int DstBlend = Shader.PropertyToID("_DstBlend");
        private static readonly int Cull = Shader.PropertyToID("_Cull");
        private static readonly int ZWrite = Shader.PropertyToID("_ZWrite");
        
        #endregion
        
        internal JungleRectangleSelector()
        {
            activators.Add(new ManipulatorActivationFilter
            {
                button = MouseButton.LeftMouse
            });
            
            if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
            {
                activators.Add(new ManipulatorActivationFilter
                {
                    button = MouseButton.LeftMouse,
                    modifiers = EventModifiers.Command
                });
            }
            else
            {
                activators.Add(new ManipulatorActivationFilter
                {
                    button = MouseButton.LeftMouse,
                    modifiers = EventModifiers.Control
                });
            }
            
            _rectangle = new RectangleSelect
            {
                style =
                {
                    position = Position.Absolute,
                    top = 0f,
                    left = 0f,
                    bottom = 0f,
                    right = 0f
                }
            };
            _active = false;
        }
        
        private Rect ComputeAxisAlignedBound(Rect position, Matrix4x4 transform)
        {
            var vectorA = transform.MultiplyPoint3x4(position.min);
            var vectorB = transform.MultiplyPoint3x4(position.max);
            return Rect.MinMaxRect
            (
                Math.Min(vectorA.x, vectorB.x),
                Math.Min(vectorA.y, vectorB.y),
                Math.Max(vectorA.x, vectorB.x), 
                Math.Max(vectorA.y, vectorB.y)
            );
        }
        
        protected override void RegisterCallbacksOnTarget()
        { 
            if (target is not GraphView)
             
                throw new InvalidOperationException("Manipulator can only be added to a GraphView");
            target.RegisterCallback<MouseDownEvent>(OnMouseDown);
            target.RegisterCallback<MouseUpEvent>(OnMouseUp);
            target.RegisterCallback<MouseMoveEvent>(OnMouseMove);
            target.RegisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOutEvent);
        }
        
        protected override void UnregisterCallbacksFromTarget()
        { 
            target.UnregisterCallback<MouseDownEvent>(OnMouseDown); 
            target.UnregisterCallback<MouseUpEvent>(OnMouseUp); 
            target.UnregisterCallback<MouseMoveEvent>(OnMouseMove); 
            target.UnregisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOutEvent);
        }
        
        private void OnMouseCaptureOutEvent(MouseCaptureOutEvent mouseCaptureOutEvent)
        {
            if (!_active) 
                return;
            _rectangle.RemoveFromHierarchy();
            _active = false;
        }

        private void OnMouseDown(MouseDownEvent mouseDownEvent)
        { 
            if (!_active)
            {
                if (target is not GraphView mouseTarget || !CanStartManipulation(mouseDownEvent))
                    return;
                if (!mouseDownEvent.actionKey)
                    mouseTarget.ClearSelection();
                mouseTarget.Add(_rectangle);
                _rectangle.Start = mouseDownEvent.localMousePosition;
                _rectangle.End = _rectangle.Start;
                _active = true;
                target.CaptureMouse();
            }
            mouseDownEvent.StopImmediatePropagation();
        }
        
        private void OnMouseUp(MouseUpEvent mouseUpEvent)
        { 
            if (!_active)
                return;
            if (target is not GraphView graphView || !CanStopManipulation(mouseUpEvent))
                return;
            graphView.Remove(_rectangle);
            _rectangle.End = mouseUpEvent.localMousePosition;
            var selectionRect = new Rect
            {
                min = new Vector2
                (
                    Math.Min(_rectangle.Start.x, _rectangle.End.x),
                    Math.Min(_rectangle.Start.y, _rectangle.End.y)
                ),
                max = new Vector2
                (
                    Math.Max(_rectangle.Start.x, _rectangle.End.x),
                    Math.Max(_rectangle.Start.y, _rectangle.End.y)
                )
            };
            selectionRect = ComputeAxisAlignedBound(selectionRect, graphView.viewTransform.matrix.inverse);
            var selection = graphView.selection;
            if (!selection.Any(ge => ge is GraphElement element && element.IsStackable()))
            {
                var newSelection = new List<ISelectable>();
                graphView.graphElements.ForEach(child =>
                {
                    var rectangle = graphView.contentViewContainer.ChangeCoordinatesTo(child, selectionRect);
                    if (!child.IsSelectable() || !child.Overlaps(rectangle) || child.IsStackable())
                        return;
                    newSelection.Add(child);
                });
                foreach (var selectable in newSelection)
                {
                    if (selection.Contains(selectable))
                    {
                        if (mouseUpEvent.actionKey)
                            graphView.RemoveFromSelection(selectable);
                    }
                    else
                        graphView.AddToSelection(selectable);
                }
            }
            _active = false;
            target.ReleaseMouse();
            mouseUpEvent.StopPropagation();
        }
        
        private void OnMouseMove(MouseMoveEvent mouseMoveEvent)
        {
          if (!_active)
            return;
          _rectangle.End = mouseMoveEvent.localMousePosition;
          mouseMoveEvent.StopPropagation();
        }

        private class RectangleSelect : ImmediateModeElement
        {
            private const float SEGMENT_LENGTH = 5f;
            
            internal Vector2 Start;
            internal Vector2 End;
            
            protected override void ImmediateRepaint()
            {
                var start = Start;
                var end = End;
                if (Start == End)
                    return;
                
                var vectorA = start + parent.layout.position;
                var vectorB = end + parent.layout.position;
                var rect = new Rect
                {
                    min = new Vector2(Math.Min(vectorA.x, vectorB.x), Math.Min(vectorA.y, vectorB.y)),
                    max = new Vector2(Math.Max(vectorA.x, vectorB.x), Math.Max(vectorA.y, vectorB.y))
                };
                
                var color = GetColor();
                var rectanglePoints = new Vector3[]
                {
                    new(rect.xMin, rect.yMin, 0f),
                    new(rect.xMax, rect.yMin, 0f),
                    new(rect.xMax, rect.yMax, 0f),
                    new(rect.xMin, rect.yMax, 0f)
                };
                
                DrawDottedLine(rectanglePoints[0], rectanglePoints[1], SEGMENT_LENGTH, color);
                DrawDottedLine(rectanglePoints[1], rectanglePoints[2], SEGMENT_LENGTH, color); 
                DrawDottedLine(rectanglePoints[2], rectanglePoints[3], SEGMENT_LENGTH, color);
                DrawDottedLine(rectanglePoints[3], rectanglePoints[0], SEGMENT_LENGTH, color);
            }
            
            private static void CreateLineMaterialIfNeeded()
            {
                if (_lineMaterial != null) 
                    return;
                
                var shader = Shader.Find($"Hidden/Internal-Colored");
                _lineMaterial = new Material(shader)
                {
                    hideFlags = HideFlags.HideAndDontSave
                };
                _lineMaterial.SetInt(SrcBlend, (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
                _lineMaterial.SetInt(DstBlend, (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                _lineMaterial.SetInt(Cull, (int)UnityEngine.Rendering.CullMode.Off);
                _lineMaterial.SetInt(ZWrite, 0);
            }
            
            private void DrawDottedLine(Vector3 pointA, Vector3 pointB, float segmentsLength, Color color)
            {
                CreateLineMaterialIfNeeded();
                _lineMaterial.SetPass(0);

                GL.PushMatrix();
                GL.Begin(GL.LINES);
                GL.Color(color);

                var distance = Vector3.Distance(pointA, pointB);
                var segmentCount = Mathf.CeilToInt(distance / segmentsLength);

                for (var i = 0; i < segmentCount; i += 2)
                {
                    GL.Vertex(Vector3.Lerp(pointA, pointB, (float) i / segmentCount));
                    GL.Vertex(Vector3.Lerp(pointA, pointB, (float) (i + 1) / segmentCount));
                }
                
                GL.End();
                GL.PopMatrix();
            }
            
            private Color GetColor()
            {
                var hexColor = EditorPrefs.GetString("Jungle.SelectionColor", "#2A67B8");
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
        }
    }
}
﻿using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal class JungleSplitView : TwoPaneSplitView
    {
        public new class UxmlFactory : UxmlFactory<JungleSplitView, UxmlTraits> { }
    }
}
﻿using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor.GUI
{
    internal sealed class JungleStickyNoteView : GraphElement
    {
        #region Properties

        private readonly JungleTree _jungleTree;
        private VisualElement _stickyNote;
        private TextField _contentField;
        private VisualElement _contentTextField;
        private readonly JungleGraphView _graphView;
        
        internal bool IsEditing => _isEditing;
        private bool _isEditing;
        
        internal bool IsSelected => _isSelected;
        private bool _isSelected;
        
        internal bool IsLocked => _isLocked;
        private bool _isLocked;
        
        internal string Content => _content;
        private string _content;

        internal string Author => _author;
        private string _author;
        
        internal string Theme => _theme;
        private string _theme;

        private bool _isMoving;
        
        private ResizeDirection _resizeDirection;
        private enum ResizeDirection
        {
            None,
            Top,
            Bottom,
            Left,
            Right,
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight
        }

        #endregion
        
        internal JungleStickyNoteView(string uid, JungleTree jungleTree, JungleGraphView graphView)
        { 
            var visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>
            (
                AssetDatabase.GetAssetPath(Resources.Load("JungleUI/JungleStickyNoteView"))
            );
            visualTree.CloneTree(this);
            
            capabilities = Capabilities.Selectable |
                           Capabilities.Movable |
                           Capabilities.Deletable |
                           Capabilities.Ascendable;
            usageHints = UsageHints.DynamicTransform;
            
            _jungleTree = jungleTree;
            _graphView = graphView;
            
            var metaData = _jungleTree.Manifest.TryGetStickyNoteMetaData(uid);
            viewDataKey = metaData.Uid;
            
            this.AddManipulator(new ContextualMenuManipulator(BuildContextualMenu));
            
            TryGetAllUxmlElements();
            
            _contentField.SetValueWithoutNotify(_content = metaData.Content);
            _contentField.pickingMode = PickingMode.Ignore;
            
            _contentTextField.RegisterCallback<BlurEvent>(BlurCallback);
            _contentTextField.AddManipulator(new ContextualMenuManipulator(populateEvent =>
            {
                populateEvent.StopImmediatePropagation();
            }));
            _contentTextField.pickingMode = PickingMode.Ignore;
            
            _stickyNote.RegisterCallback<MouseEnterEvent>(MouseEnterCallback);
            _stickyNote.RegisterCallback<MouseLeaveEvent>(MouseLeaveCallback);
            _stickyNote.RegisterCallback<MouseDownEvent>(MouseDownCallback);
            _stickyNote.RegisterCallback<MouseUpEvent>(MouseUpCallback);
            
            _stickyNote.style.borderBottomColor = new Color(0f, 0f, 0f, 0.65f);
            AddToClassList(_theme = metaData.Theme);
            if (JunglePreferencesUtility.StickyNoteFont)
            {
                AddToClassList("handwritten-font");
                var fontFilePath = AssetDatabase.GetAssetPath(Resources.Load("Nanum Pen Script"));
                if (!string.IsNullOrEmpty(fontFilePath))
                {
                    _contentTextField.style.unityFontDefinition = new StyleFontDefinition();
                    _contentTextField.style.unityFont = AssetDatabase.LoadAssetAtPath<Font>(fontFilePath);
                }
                else Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null,
                    "[<b>Jungle</b>] > [<b>?</b>] Failed to load sticky note handwritten font.\n" +
                    "<b>Click for more information</b>\n\n" +
                    "<b>Explanation:</b>\n" +
                    "The special font used for notes in the Jungle Editor could not be found in the project.\n\n" +
                    "<b>How to fix:</b>\n" +
                    "To restore the font, please add the font with the exact name \"Nanum Pen Script\" to a resources " +
                    "folder in this project.\n\n" +
                    "<b>You can silence this error by disabling \"Handwritten Note Font\" in the appearance preferences.</b>"
                );
            }
            
            TryRegisterAllResizeAnchors();
            SetLockState(metaData.IsLocked);
            SetPosition(new Rect(metaData.GraphPosition, metaData.GraphSize));
        }

        private void MouseEnterCallback(MouseEnterEvent _)
        {
            if (_isMoving)
                return;
            if (!_isLocked)
            {
                _stickyNote.style.borderBottomWidth = 2f;
            }
        }
        
        private void MouseLeaveCallback(MouseLeaveEvent _)
        {
            if (_isMoving)
                return;
            if (!_isSelected)
            {
                _stickyNote.style.borderBottomWidth = 0f;
            }
        }
        
        private void MouseDownCallback(MouseDownEvent mouseEvent)
        {
            if (mouseEvent.button != 0)
                return;

            if (!_isLocked)
            {
                _stickyNote.style.borderBottomWidth = 4f;
                _isMoving = true;
            }
                
            if (_isLocked || !_isSelected) 
                return;
            if (!_isEditing)
                StartContentEditing();
        }
        
        private void MouseUpCallback(MouseUpEvent mouseEvent)
        {
            if (mouseEvent.button != 0 || _isLocked)
                return;

            if (_isMoving)
            {
                _isMoving = false;
                _stickyNote.style.borderBottomWidth = 2f;
            }
        }
        
        private void GraphMouseUpCallback(MouseUpEvent mouseEvent)
        {
            if (mouseEvent.button == 0)
                StopResizeToMouseCursor();
        }

        private void GraphMouseMovedCallback(MouseMoveEvent mouseEvent)
        {
            var mousePositionInGraph = parent.WorldToLocal(mouseEvent.mousePosition);
            UpdateResizeToMouseCursor(mousePositionInGraph);
        }
        
        public override void OnSelected()
        {
            if (_isLocked)
                return;
            
            _stickyNote.style.borderBottomWidth = 2f;
            _isSelected = true;
            
            base.OnSelected();
        }
        
        public override void OnUnselected()
        {
            _stickyNote.style.borderBottomWidth = 0f;
            _isEditing = false;
            _isSelected = false;
            
            base.OnUnselected();
        }
        
        private void TryGetAllUxmlElements()
        {
            var stickyNote = this.Q("sticky-note");
            if (stickyNote != null)
            {
                _stickyNote = stickyNote;
                stickyNote.Add
                (
                    new TextField
                    {
                        name = "content-field",
                        multiline = true
                    }
                );
            }
            
            var contentField = this.Q<TextField>("content-field");
            if (contentField != null)
            {
                _contentField = contentField;
            }

#if UNITY_2021
            var contentTextField = _contentField?.Q("unity-text-input");
#else
            var contentTextField = _contentField?.Q<TextField>();
#endif
            if (contentTextField != null)
            {
                _contentTextField = contentTextField;
            }
        }

        private void TryRegisterAllResizeAnchors()
        {
            var anchors = this.Q("resize-anchors");
            
            var topExpandAnchor = anchors.Q("top-expand-anchor");
            if (topExpandAnchor != null)
            {
                topExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.Top);
                });
            }
            
            var bottomExpandAnchor = anchors.Q("bottom-expand-anchor");
            if (bottomExpandAnchor != null)
            {
                bottomExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.Bottom);
                });
            }
            
            var leftExpandAnchor = anchors.Q("left-expand-anchor");
            if (leftExpandAnchor != null)
            {
                leftExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.Left);
                });
            }
            
            var rightExpandAnchor = anchors.Q("right-expand-anchor");
            if (rightExpandAnchor != null)
            {
                rightExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.Right);
                });
            }
            
            var topLeftExpandAnchor = anchors.Q("top-left-expand-anchor");
            if (topLeftExpandAnchor != null)
            {
                topLeftExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.TopLeft);
                });
            }
            
            var topRightExpandAnchor = anchors.Q("top-right-expand-anchor");
            if (topRightExpandAnchor != null)
            {
                topRightExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.TopRight);
                });
            }
            
            var bottomLeftExpandAnchor = anchors.Q("bottom-left-expand-anchor");
            if (bottomLeftExpandAnchor != null)
            {
                bottomLeftExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.BottomLeft);
                });
            }
            
            var bottomRightExpandAnchor = anchors.Q("bottom-right-expand-anchor");
            if (bottomRightExpandAnchor != null)
            {
                bottomRightExpandAnchor.RegisterCallback<MouseDownEvent>(mouseEvent =>
                {
                    if (mouseEvent.button == 0)
                        StartResizeToMouseCursor(ResizeDirection.BottomRight);
                });
            }
        }
        
        internal void SetTheme(string theme)
        {
            RemoveFromClassList(_theme);
            Undo.RecordObject(_jungleTree.Manifest, $"Updated note theme in {_jungleTree.name}");
            _jungleTree.Manifest.UpdateStickyNoteTheme(viewDataKey, theme);
            _theme = theme;
            AddToClassList(_theme);
        }
        
        internal void SetLockState(bool state)
        {
            _jungleTree.Manifest.UpdateStickyNoteIsLocked(viewDataKey, state);
            _isLocked = state;
            
            if (_isLocked)
            {
                RemoveFromClassList("unlocked");
                _stickyNote.style.borderBottomWidth = 0f;
                
                capabilities = Capabilities.Deletable;
                StopContentEditing();
            }
            else
            {
                AddToClassList("unlocked");
                capabilities = Capabilities.Selectable |
                               Capabilities.Movable |
                               Capabilities.Deletable |
                               Capabilities.Ascendable;
            }
        }

        internal void StartContentEditing()
        {
            _contentTextField.pickingMode = PickingMode.Position;
            _contentTextField.Focus();
            _isEditing = true;
        }
        
        private void StopContentEditing()
        {
            _contentTextField.pickingMode = PickingMode.Ignore;
            _content = _contentField?.value ?? string.Empty;
            Undo.RecordObject(_jungleTree.Manifest, $"Updated note content in {_jungleTree.name}");
            _jungleTree.Manifest.UpdateStickyNoteContent(viewDataKey, _content);
            _isEditing = false;
        }
        
        private void StartResizeToMouseCursor(ResizeDirection direction)
        {
            if (_isLocked)
                return;
            _resizeDirection = direction;
            
            capabilities = Capabilities.Selectable |
                           Capabilities.Deletable |
                           Capabilities.Ascendable;
            
            _graphView.RegisterCallback<MouseMoveEvent>(GraphMouseMovedCallback);
            _graphView.RegisterCallback<MouseUpEvent>(GraphMouseUpCallback);
            _graphView.SetRectangleSelectionState(false);
            
            _stickyNote.style.borderBottomWidth = 2f;
        }
        
        private void StopResizeToMouseCursor()
        {
            _resizeDirection = ResizeDirection.None;
            
            if (!_isLocked)
            {
                capabilities = Capabilities.Selectable |
                               Capabilities.Movable |
                               Capabilities.Deletable |
                               Capabilities.Ascendable;
            }
            
            Undo.RecordObject(_jungleTree.Manifest, $"Resized note in {_jungleTree.name}");
            _jungleTree.Manifest.UpdateStickyNoteGraphPosition(viewDataKey, GetPosition().position);
            _jungleTree.Manifest.UpdateStickyNoteGraphSize(viewDataKey, GetPosition().size);
            
            _graphView.UnregisterCallback<MouseMoveEvent>(GraphMouseMovedCallback);
            _graphView.UnregisterCallback<MouseUpEvent>(GraphMouseUpCallback);
            _graphView.SetRectangleSelectionState(true);
            
            _stickyNote.style.borderBottomWidth = 0f;
        }
        
        private void UpdateResizeToMouseCursor(Vector2 mousePositionInGraph)
        {
            if (_resizeDirection == ResizeDirection.None)
                return;
            
            var stickyNotePosition = GetPosition();
            var stickyNoteSize = stickyNotePosition.size;
            var stickyNotePositionMin = stickyNotePosition.min;
            var stickyNotePositionMax = stickyNotePosition.max;
            
            var stickyNotePositionMinX = stickyNotePositionMin.x;
            var stickyNotePositionMinY = stickyNotePositionMin.y;
            var stickyNotePositionMaxX = stickyNotePositionMax.x;
            var stickyNotePositionMaxY = stickyNotePositionMax.y;
            
            var stickyNoteSizeX = stickyNoteSize.x;
            var stickyNoteSizeY = stickyNoteSize.y;
            
            var mousePositionInGraphX = mousePositionInGraph.x;
            var mousePositionInGraphY = mousePositionInGraph.y;
            
            switch (_resizeDirection)
            {
                case ResizeDirection.Top:
                    stickyNotePositionMinY = mousePositionInGraphY;
                    stickyNoteSizeY = stickyNotePositionMaxY - mousePositionInGraphY;
                    break;
                case ResizeDirection.Bottom:
                    stickyNoteSizeY = mousePositionInGraphY - stickyNotePositionMinY;
                    break;
                case ResizeDirection.Left:
                    stickyNotePositionMinX = mousePositionInGraphX;
                    stickyNoteSizeX = stickyNotePositionMaxX - mousePositionInGraphX;
                    break;
                case ResizeDirection.Right:
                    stickyNoteSizeX = mousePositionInGraphX - stickyNotePositionMinX;
                    break;
                case ResizeDirection.TopLeft:
                    stickyNotePositionMinX = mousePositionInGraphX;
                    stickyNoteSizeX = stickyNotePositionMaxX - mousePositionInGraphX;
                    stickyNotePositionMinY = mousePositionInGraphY;
                    stickyNoteSizeY = stickyNotePositionMaxY - mousePositionInGraphY;
                    break;
                case ResizeDirection.TopRight:
                    stickyNoteSizeX = mousePositionInGraphX - stickyNotePositionMinX;
                    stickyNotePositionMinY = mousePositionInGraphY;
                    stickyNoteSizeY = stickyNotePositionMaxY - mousePositionInGraphY;
                    break;
                case ResizeDirection.BottomLeft:
                    stickyNotePositionMinX = mousePositionInGraphX;
                    stickyNoteSizeX = stickyNotePositionMaxX - mousePositionInGraphX;
                    stickyNoteSizeY = mousePositionInGraphY - stickyNotePositionMinY;
                    break;
                case ResizeDirection.BottomRight:
                    stickyNoteSizeX = mousePositionInGraphX - stickyNotePositionMinX;
                    stickyNoteSizeY = mousePositionInGraphY - stickyNotePositionMinY;
                    break;
            }
            
            stickyNoteSizeX = Mathf.Clamp(stickyNoteSizeX, 55f, 1000f);
            stickyNoteSizeY = Mathf.Clamp(stickyNoteSizeY, 55f, 1000f);
            SetPosition(new Rect
            (
                new Vector2(stickyNotePositionMinX, stickyNotePositionMinY),
                new Vector2(stickyNoteSizeX, stickyNoteSizeY)
            ));
        }
        
        private void BlurCallback(BlurEvent _)
        {
            Undo.RecordObject(_jungleTree.Manifest, $"Updated note content in {_jungleTree.name}");
            _jungleTree.Manifest.UpdateStickyNoteContent(viewDataKey, _contentField?.value);
            StopContentEditing();
        }
        
        // LEAVE THIS. IT MAKES SURE THE CONTEXT MENU BUILDS WHEN THE VIEW IS RIGHT CLICKED ----------------------------
        private void BuildContextualMenu(ContextualMenuPopulateEvent context) { }
        // LEAVE THIS. IT MAKES SURE THE CONTEXT MENU BUILDS WHEN THE VIEW IS RIGHT CLICKED ----------------------------
    }
}

﻿using System;
using UnityEngine.UIElements;

namespace Jungle.Editor
{
    internal static class JungleBrowser
    {
        internal static Action<Type> OnDragInitiated;
        internal static Action       OnDragCancelled;
        
        internal static bool IsValidDrag()
        {
            return _valid;
        }
        private static bool _valid;
        
        private static VisualElement _graphViewElement;
        private static VisualElement _rootViewElement;
        private static Type _request = typeof(void);
        
        internal static void Initialize(VisualElement root, VisualElement graph)
        {
            _rootViewElement = root;
            _rootViewElement.RegisterCallback<MouseLeaveEvent>(_ => InvalidDragCallback());
            _rootViewElement.RegisterCallback<MouseUpEvent>(_ => InvalidDragCallback());
            
            _graphViewElement = graph;
            _graphViewElement.RegisterCallback<MouseEnterEvent>(MouseEnterGraphViewCallback);
        }
        
        internal static void SetContext(Type jungleNodeType)
        {
            _request = jungleNodeType;
            _valid = true;
        }
        
        private static void InvalidDragCallback()
        {
            _valid = false;
            _request = typeof(void);
            OnDragCancelled?.Invoke();
        }
        
        private static void MouseEnterGraphViewCallback(MouseEnterEvent _)
        {
            if (_request == typeof(void))
                return;
            
            if (JungleEditor.Instance != null)
                JungleEditor.Instance.StartDraggingNodeInGraphView(_request);
            
            InvalidDragCallback();
        }
    }
}

﻿using System;
using System.Collections.Generic;
using Jungle.Nodes;
using UnityEditor;
using UnityEngine;

namespace Jungle.Editor
{
    [FilePath("JungleEditor.clipboard", FilePathAttribute.Location.PreferencesFolder)]
    internal class JungleClipboard : ScriptableSingleton<JungleClipboard>
    {
        [SerializeField] [HideInInspector]
        private ClipboardItem[] clipboard = Array.Empty<ClipboardItem>();
        
        internal void BuildClipboard(JungleNode[] nodes)
        {
            var queriedClipboard = new List<ClipboardItem>();
            foreach (var node in nodes)
            {
                var nodeMeta = node.JungleTree.Manifest.TryGetNodeMetaData(node);
                queriedClipboard.Add(new ClipboardItem(node, nodeMeta.GraphPosition));
            }
            clipboard = queriedClipboard.ToArray();
        }
        
        internal ClipboardItem[] GetClipboard()
        {
            return clipboard;
        }
        
        internal void ClearClipboard()
        {
            clipboard = Array.Empty<ClipboardItem>();
        }
    }
    
    [Serializable]
    internal struct ClipboardItem
    {
        internal JungleNode Node => node;
        [SerializeField] [HideInInspector]
        private JungleNode node;
            
        internal Vector2 GraphPosition => graphPosition;
        [SerializeField] [HideInInspector]
        private Vector2 graphPosition;
            
        internal ClipboardItem(JungleNode node, Vector2 graphPosition)
        {
            this.node = node;
            this.graphPosition = graphPosition;
        }
    }
    
    internal static class JungleClipboardUtility
    {
        internal static void SetClipboard(JungleNode[] nodes)
        {
            // Clear the clipboard so we always start on a clean slate
            ClearClipboard();
            
            // Make sure to remove all nodes that should not be copied
            var queriedClipboard = new List<JungleNode>(nodes);
            queriedClipboard.RemoveAll(node => node.GetType() == typeof(StartNode));
            
            JungleClipboard.instance.BuildClipboard(queriedClipboard.ToArray());
        }
        
        internal static ClipboardItem[] GetClipboard()
        {
            return JungleClipboard.instance.GetClipboard();
        }
        
        internal static void ClearClipboard()
        {
            JungleClipboard.instance.ClearClipboard();
        }
        
        internal static bool HasClipboard()
        {
            return GetClipboard().Length > 0;
        }
    }
}

using System;
using System.Linq;
using Jungle.Editor.GUI;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements;

namespace Jungle.Editor
{
    internal class JungleEditor : EditorWindow
    {
        #region Properties
        
        private const float MIN_WINDOW_WIDTH = 800f;
        private const float MIN_WINDOW_HEIGHT = 400f;
        private const int MAX_HEADER_LABEL_LENGTH = 48;
        private const int MAX_SELECTED_NODES_LISTED = 8;
        
        internal static JungleEditor Instance
        {
            get;
            private set;
        }

        private int InspectorWidth
        {
            get
            {
                if (_inspectorWidth == -1)
                    _inspectorWidth = EditorPrefs.GetInt("Jungle.InspectorWidth", 300);
                return _inspectorWidth;
            }
            set => EditorPrefs.SetInt("Jungle.InspectorWidth", _inspectorWidth = value);
        }
        private int _inspectorWidth = -1;
        
        private int InspectorHeight
        {
            get
            {
                if (_inspectorHeight == -1)
                    _inspectorHeight = EditorPrefs.GetInt("Jungle.InspectorWidth", 300);
                return _inspectorHeight;
            }
            set => EditorPrefs.SetInt("Jungle.InspectorWidth", _inspectorHeight = value);
        }
        private int _inspectorHeight = -1;
        
        private JungleTree _openedJungleTree;
        private UnityEditor.Editor _inspectorEditor;
        private IMGUIContainer _inspectorView;
        private JungleExplorerView _explorerView;
        private JungleGraphView _graphView;
        
        private JungleSplitView _splitView;
        private VisualElement _controlViewContainer;
        private JungleSplitView _controlSplitView;
        private VisualElement _inspectorViewContainer;
        
        private Label _treeNameLabel;
        private Label _nodeNameLabel;
        
        internal static string ShortenString(string input, int maxLength)
        {
            if (input.Length <= maxLength)
            {
                return input;
            }
            return input.Substring(0, maxLength - 3) + "...";
        }
        
        #endregion

        internal static void OpenEditor(JungleTree jungleTree)
        {
            Instance = GetWindow<JungleEditor>();
            Instance._openedJungleTree = jungleTree;
            Instance.BuildGUI();
        }
        
        private static void CheckJungleTreeDeleted()
        {
            if (Instance == null || Instance._openedJungleTree == null)
                Instance.Close();
        }
        
        internal void StartDraggingNodeInGraphView(Type jungleNodeType)
        {
            _graphView?.AddNodeAndFollowCursor(jungleNodeType);
        }
        
        private void OnEnable()
        {
            titleContent = new GUIContent
            (
                "Jungle Editor", 
                Resources.Load<Texture2D>
                (
                    EditorGUIUtility.isProSkin
                        ? "d_JungleEditorIcon"
                        : "JungleEditorIcon"
                )
            );
            minSize = new Vector2(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT);
            JungleTreeCache.OnJungleTreeDeleted += CheckJungleTreeDeleted;
        }
        
        private void OnDisable()
        {
            JungleTreeCache.OnJungleTreeDeleted -= CheckJungleTreeDeleted;
        }

        private void OnBecameInvisible()
        {
            JungleEditorUtility.ClearLastOpenedJungleTree();
        }
        
        private void Update()
        {
            _graphView?.PerformUpdate();
        }

        private void BuildGUI()
        {
            CheckJungleTreeDeleted();
            rootVisualElement.Clear();
            
            var jungleEditorFilePath = AssetDatabase.GetAssetPath(Resources.Load("JungleUI/JungleEditorView"));
            AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(jungleEditorFilePath).CloneTree(rootVisualElement);
            
            _treeNameLabel = rootVisualElement.Q<Label>("tree-name-label");
            _nodeNameLabel = rootVisualElement.Q<Label>("node-name-label");
            _graphView = rootVisualElement.Q<JungleGraphView>("graph-view");
            _inspectorView = rootVisualElement.Q<IMGUIContainer>("inspector-view");
            
            _splitView = rootVisualElement.Q<JungleSplitView>("split-view");
            _controlViewContainer = _splitView.Q("control");
            _controlSplitView = rootVisualElement.Q<JungleSplitView>("left-split-view");
            _inspectorViewContainer = _controlSplitView.Q("inspector");
            
            _splitView.fixedPaneInitialDimension = InspectorWidth;
            _controlSplitView.fixedPaneInitialDimension = InspectorHeight;
            
            // Listen for when the panels are moved
            _controlViewContainer.RegisterCallback<GeometryChangedEvent>(_ =>
            {
                InspectorWidth = (int)_controlViewContainer.style.width.value.value;
            });
            _inspectorViewContainer.RegisterCallback<GeometryChangedEvent>(_ =>
            {
                InspectorHeight = (int)_inspectorViewContainer.style.height.value.value;
            });
            
            _graphView.SetupGraphView(_openedJungleTree);
            InspectNothing();
            
            JungleBrowser.Initialize(rootVisualElement, _graphView);
            _explorerView = new JungleExplorerView(rootVisualElement);
        }
        
        internal void UpdateGraphLabels()
        {
            // Draw Jungle Tree title
            _treeNameLabel.text = ShortenString
            (
                _openedJungleTree.name,
                MAX_HEADER_LABEL_LENGTH
            );
            
            // Draw selected nodes list
            _nodeNameLabel.text = string.Empty;
            if (_graphView == null || 
                _graphView.SelectedNodeViews.Count == 0 || 
                _graphView.SelectedNodeViews.Any(view => view.Node == null))
            {
                return;
            }
            var nodeSelectionList = string.Empty;
            var nodesSelectedCount = _graphView.SelectedNodeViews.Count;
            for (var i = 0; i < MAX_SELECTED_NODES_LISTED; i++)
            {
                if (i + 1 == MAX_SELECTED_NODES_LISTED && nodesSelectedCount > MAX_SELECTED_NODES_LISTED)
                {
                    nodeSelectionList += $"{nodesSelectedCount - MAX_SELECTED_NODES_LISTED - 1} more selected";
                    break;
                }
                if (i <= nodesSelectedCount - 1)
                {
                    nodeSelectionList += ShortenString
                    (
                        _graphView.SelectedNodeViews[i].Node.name,
                        MAX_HEADER_LABEL_LENGTH
                    ) + "\n";
                }
                else break;
            }
            _nodeNameLabel.text = nodeSelectionList;
        }
        
        internal JungleNode InspectorTarget => _inspectorEditor != null ? _inspectorEditor.target as JungleNode : null;
        
        internal void Inspect(JungleNode jungleNode)
        {
            if (jungleNode != null)
            {
                DrawNodeInspector(jungleNode);
                UpdateGraphLabels();
            }
            else InspectNothing();
        }
        
        internal void InspectNothing()
        {
            DrawEmptyNodeInspector();
            UpdateGraphLabels();
        }
        
        private void DrawNodeInspector(JungleNode jungleNode)
        {
            _inspectorEditor = UnityEditor.Editor.CreateEditor(jungleNode);
            _inspectorView.onGUIHandler = delegate
            {
                if (_inspectorEditor == null)
                    return;
                
                var targetNode = _inspectorEditor.target as JungleNode;
                if (targetNode == null)
                {
                    _inspectorEditor = null;
                    return;
                }
                GUILayout.Space(4f);
                GUILayout.BeginHorizontal();
                    GUILayout.Space(6f);
                    targetNode.name = GUILayout.TextField(targetNode.name);
                    GUILayout.Space(3f);
                GUILayout.EndHorizontal();
                    
                if (string.IsNullOrEmpty(targetNode.name))
                    targetNode.name = "Untitled Node";
                
                GUILayout.BeginVertical(EditorStyles.inspectorDefaultMargins);

                try
                {
                    _inspectorEditor.OnInspectorGUI();
                }
                catch (Exception e)
                {
                    EditorGUILayout.HelpBox
                    (
                        "An error occurred while trying to draw the nodes inspector.",
                        MessageType.Error
                    );
                    
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    
                        GUILayout.Label("Message", EditorStyles.boldLabel);
                        GUILayout.Label($"{e.Message}", EditorStyles.wordWrappedLabel);
                        
                        GUILayout.Space(5f);
                        
                        GUILayout.Label("Stack Trace", EditorStyles.boldLabel);
                        GUILayout.Label($"{e.StackTrace}", EditorStyles.wordWrappedMiniLabel);
                        
                    GUILayout.EndVertical();
                }
                
                GUILayout.EndVertical();
            };
        }
        
        private void DrawEmptyNodeInspector()
        {
            _inspectorEditor = null;
            _inspectorView.onGUIHandler = delegate
            {
                UnityEngine.GUI.enabled = false;
                GUILayout.Space(4f);
                GUILayout.BeginHorizontal();
                    GUILayout.Space(6f);
                    GUILayout.TextField(string.Empty);
                    GUILayout.Space(3f);
                GUILayout.EndHorizontal();
                GUILayout.BeginVertical(EditorStyles.inspectorDefaultMargins);
                    GUILayout.Label("Select a node...");
                GUILayout.EndVertical();
            };
        }
    }
    
    internal static class JungleEditorUtility
    {
        private static JungleTree TryGetLastOpenedJungleTree()
        {
            var openedJungleTreeGuid = EditorPrefs.GetString
            (
                "Jungle.OpenedJungleTreeGUID",
                string.Empty
            );
            if (string.IsNullOrEmpty(openedJungleTreeGuid))
                return null;
            
            var jungleTreeAsset = JungleTreeCache.GetAllJungleTrees().FirstOrDefault
            (
                jungleTree => AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(jungleTree)) == openedJungleTreeGuid
            );
            if (jungleTreeAsset == null)
                return null;
            return jungleTreeAsset;
        }
        
        private static void SaveLastOpenedJungleTree(JungleTree jungleTree)
        {
            if (jungleTree == null)
            {
                EditorPrefs.SetString
                (
                    "Jungle.OpenedJungleTreeGUID",
                    string.Empty
                );
                return;
            }
            var jungleTreeGuid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(jungleTree));
            EditorPrefs.SetString
            (
                "Jungle.OpenedJungleTreeGUID",
                jungleTreeGuid
            );
        }
        
        [OnOpenAsset]
        private static bool OpenAssetCallback(int _, int __)
        {
            if (Selection.activeObject == null || Selection.activeObject.GetType() != typeof(JungleTree))
                return false;
            
            var jungleTree = Selection.activeObject as JungleTree;
            JungleEditor.OpenEditor(jungleTree);
            SaveLastOpenedJungleTree(jungleTree);
            return true;
        }
        
        [InitializeOnLoadMethod]
        private static void InitializeOnLoadCallback()
        {
            EditorApplication.projectWindowItemOnGUI += OpenEditorCallback;
        }
        
        private static void OpenEditorCallback(string _, Rect __)
        {
            EditorApplication.projectWindowItemOnGUI -= OpenEditorCallback;
            
            var jungleTree = TryGetLastOpenedJungleTree();
            if (jungleTree == null)
                return;
            JungleEditor.OpenEditor(jungleTree);
        }

        internal static void ClearLastOpenedJungleTree()
        {
            SaveLastOpenedJungleTree(null);
        }
    }
}

﻿using UnityEditor;
using UnityEngine;

namespace Jungle.Editor
{
    internal class JunglePreferences : EditorWindow
    {
        #region Properties

        private const float WINDOW_WIDTH = 300f;
        private const float WINDOW_HEIGHT = 400f;

        private GUILayoutOption ButtonLayoutOptions => GUILayout.Width(WINDOW_WIDTH / 2f);
        private GUIStyle ActiveButtonStyle => new(EditorStyles.toolbarButton)
        {
            normal =
            {
                background = !EditorGUIUtility.isProSkin ? Texture2D.whiteTexture : Texture2D.grayTexture
            }
        };
        private GUIStyle InactiveButtonStyle => new(EditorStyles.toolbarButton);
        private int _openTabIndex;
        
        #endregion
        
        [MenuItem("Jungle/Preferences/Open", priority = 1)]
        internal static void OpenWindow()
        {
            GetWindowWithRect<JunglePreferences>
            (
                new Rect(0f, 0f, WINDOW_WIDTH, WINDOW_HEIGHT),
                true,
                "Jungle Preferences"
            );
        }
        
        [MenuItem("Jungle/Preferences/Reset to Default")]
        private static void ResetPreferencesToDefault()
        {
            var choice = EditorUtility.DisplayDialog
            (
                "Reset all Jungle Preferences to Default?",
                "Are you sure you would like to reset all preferences to their default values? " +
                "This cannot be undone.",
                "Yes",
                "No"
            );
            if (!choice) return;
            JunglePreferencesUtility.ResetPreferencesToDefault();
        }
        
        private void OnGUI()
        {
            DrawTabs();
            switch (_openTabIndex)
            {
                case 0:
                    DrawGeneralPreferences();
                    break;
                case 1:
                    DrawAboutSection();
                    break;
            }
        }
        
        private void DrawTabs()
        {
            GUILayout.BeginHorizontal(EditorStyles.toolbar);
                var generalButtonStyle = _openTabIndex == 0 ? ActiveButtonStyle : InactiveButtonStyle;
                if (GUILayout.Button("General", generalButtonStyle, ButtonLayoutOptions))
                    _openTabIndex = 0;
                var aboutButtonStyle = _openTabIndex == 1 ? ActiveButtonStyle : InactiveButtonStyle;
                if (GUILayout.Button("About", aboutButtonStyle, ButtonLayoutOptions))
                    _openTabIndex = 1;
            GUILayout.EndHorizontal();
        }
        
        private void DrawGeneralPreferences()
        {
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Validation", EditorStyles.boldLabel);
                JunglePreferencesUtility.RefreshValidationInPlayMode = EditorGUILayout.Toggle
                (
                    "Refresh in Play Mode", 
                    JunglePreferencesUtility.RefreshValidationInPlayMode
                );
                JunglePreferencesUtility.RefreshDuringBuild = EditorGUILayout.Toggle
                (
                    "Refresh During Build", 
                    JunglePreferencesUtility.RefreshDuringBuild
                );
            GUILayout.EndVertical();

            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.BeginHorizontal();
                    GUILayout.Label("Cache", EditorStyles.boldLabel, GUILayout.Width(40f));
                    GUILayout.Label
                    (
                        $"Allocation: {JungleIconCache.instance.GetCacheAllocationSize()}/{JunglePreferencesUtility.MaxCacheSize}",
                        EditorStyles.wordWrappedMiniLabel
                    );
                GUILayout.EndHorizontal();
                
                var previousUseCacheState = JunglePreferencesUtility.UseCaching;
                JunglePreferencesUtility.UseCaching = EditorGUILayout.Toggle
                (
                    "Use Caching",
                    JunglePreferencesUtility.UseCaching
                );
                if (!previousUseCacheState && previousUseCacheState != JunglePreferencesUtility.UseCaching)
                    JungleIconCache.instance.BuildIconCache();
                else if (previousUseCacheState && previousUseCacheState != JunglePreferencesUtility.UseCaching)
                    JungleIconCache.instance.ClearIconCache();
                
                if (!JunglePreferencesUtility.UseCaching)
                {
                    EditorGUILayout.HelpBox
                    (
                        "While disabling caching reduces memory usage, it could result in long load times.",
                        MessageType.Warning
                    );
                }
                
                UnityEngine.GUI.enabled = JunglePreferencesUtility.UseCaching;
                
                var maxCacheSize = EditorGUILayout.IntField
                (
                    "Max Cache Size",
                    JunglePreferencesUtility.MaxCacheSize
                );
                JunglePreferencesUtility.MaxCacheSize = (int)Mathf.Clamp
                (
                    maxCacheSize,
                    16,
                    128
                );
                if (maxCacheSize < JungleIconCache.instance.GetCacheAllocationSize())
                {
                    EditorGUILayout.HelpBox
                    (
                        "The cache size is currently larger than the allocated cache size. Clear the cache" +
                        "to resolve this issue.",
                        MessageType.Warning
                    );
                }
                if (maxCacheSize >= 64)
                {
                    EditorGUILayout.HelpBox
                    (
                        "Large cache sizes may significantly increase the editors memory usage.",
                        MessageType.Error
                    );
                }
                
                UnityEngine.GUI.enabled = true;
            GUILayout.EndVertical();
            
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Appearance", EditorStyles.boldLabel);
                
                JunglePreferencesUtility.SelectionColor = EditorGUI.ColorField
                (
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("Selection Box"), 
                    JunglePreferencesUtility.SelectionColor, 
                    true, 
                    false, 
                    false
                );

                JunglePreferencesUtility.StickyNoteFont = EditorGUILayout.Toggle
                (
                    "Handwritten Note Font",
                    JunglePreferencesUtility.StickyNoteFont
                );
                
                GUILayout.Space(5f);
                
                JunglePreferencesUtility.NonePortColor = EditorGUI.ColorField
                (   
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("None Port"), 
                    JunglePreferencesUtility.NonePortColor, 
                    true, 
                    false, 
                    false
                );
                JunglePreferencesUtility.StructPortColor = EditorGUI.ColorField
                (
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("Struct Port"), 
                    JunglePreferencesUtility.StructPortColor, 
                    true, 
                    false, 
                    false
                );
                JunglePreferencesUtility.PrimitivePortColor = EditorGUI.ColorField
                (
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("Primitive Port"), 
                    JunglePreferencesUtility.PrimitivePortColor, 
                    true, 
                    false, 
                    false
                );
                JunglePreferencesUtility.UnityMonoBehaviourPortColor = EditorGUI.ColorField
                (
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("MonoBehaviour Port"), 
                    JunglePreferencesUtility.UnityMonoBehaviourPortColor, 
                    true, 
                    false, 
                    false
                );
                JunglePreferencesUtility.UnityScriptableObjectPortColor = EditorGUI.ColorField
                (
                    EditorGUILayout.GetControlRect(), 
                    new GUIContent("ScriptableObject Port"),
                    JunglePreferencesUtility.UnityScriptableObjectPortColor, 
                    true, 
                    false, 
                    false
                );

                GUILayout.Space(2f);
                UnityEngine.GUI.enabled = false;
                GUILayout.Label
                (
                    "Changes will apply when you reopen the Jungle Editor.",
                    EditorStyles.wordWrappedMiniLabel
                );
                UnityEngine.GUI.enabled = true;
            GUILayout.EndVertical();
                
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Miscellaneous", EditorStyles.boldLabel);
                JunglePreferencesUtility.Signature = EditorGUILayout.TextField
                (
                    "Signature",
                    JunglePreferencesUtility.Signature
                );
            GUILayout.EndVertical();
        }
        
        private void DrawAboutSection()
        {
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Links", EditorStyles.boldLabel);
                if (GUILayout.Button("Documentation"))
                {
                    Application.OpenURL("https://junglesequencer.com/docs/welcome");
                }
                if (GUILayout.Button("Terms and Conditions"))
                {
                    Application.OpenURL("https://jackedupsoftware.com/legal/terms-and-conditions");
                }
            GUILayout.EndVertical();
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Credit", EditorStyles.boldLabel);
            
                GUILayout.Label("- Designed and programmed by Jack Randolph.", EditorStyles.wordWrappedLabel);
                
                GUILayout.Space(5f);
                GUILayout.BeginHorizontal();
                    GUILayout.Label
                    (
                        "- Nanum Pen Script font by Sandoll Communications Inc.",
                        EditorStyles.wordWrappedLabel,
                        GUILayout.MaxWidth(200f)
                    );
                    if (GUILayout.Button("License"))
                        Application.OpenURL("https://fonts.google.com/specimen/Nanum+Pen+Script/about?query=Sandoll");
                GUILayout.EndHorizontal();
                
                GUILayout.BeginHorizontal();
                    GUILayout.Label
                    (
                        "- Graph View library by Unity Technologies.",
                        EditorStyles.wordWrappedLabel,
                        GUILayout.MaxWidth(200f)
                    );
                GUILayout.EndHorizontal();
                
                GUILayout.BeginHorizontal();
                    GUILayout.Label
                    (
                        "- All Icons by Jacked Up Software LLC.",
                        EditorStyles.wordWrappedLabel,
                        GUILayout.MaxWidth(200f)
                    );
                GUILayout.EndHorizontal();
                
                GUILayout.Space(5f);
                GUILayout.BeginHorizontal();
                    var icon = AssetDatabase.LoadAssetAtPath<Texture>(AssetDatabase.GetAssetPath(Resources.Load("JUS-Logo")));
                    var iconRect = GUILayoutUtility.GetRect
                    (
                        GUIContent.none,
                        GUIStyle.none,
                        GUILayout.Height(48f),
                        GUILayout.Width(48f)
                    );
                    UnityEngine.GUI.DrawTexture(iconRect, icon);
                    GUILayout.BeginVertical();
                        GUILayout.Space(6f);
                        GUILayout.Label
                        (
                            "\u00a9 Jacked Up Software LLC.\nAll Rights Reserved.",
                            EditorStyles.wordWrappedLabel
                        );
                    GUILayout.EndVertical();
                GUILayout.EndHorizontal();
            GUILayout.EndVertical();
        }
    }
    
    internal static class JunglePreferencesUtility
    {
        private const string NONE_PORT_COLOR = "#768084";
        private const string STRUCT_PORT_COLOR = "#b52b6a";
        private const string PRIMITIVE_PORT_COLOR = "#2a67b8";
        private const string UNITY_MONO_BEHAVIOUR_PORT_COLOR = "#bd8e04";
        private const string UNITY_SCRIPTABLE_OBJECT_PORT_COLOR = "#07ad55";
        private const string SELECTION_COLOR = "#2A67B8";
        
        internal static void ResetPreferencesToDefault()
        {
            RefreshValidationInPlayMode = false;
            RefreshDuringBuild = true;
            UseCaching = true;
            MaxCacheSize = 32;
            Signature = string.Empty;
            ColorUtility.TryParseHtmlString(NONE_PORT_COLOR, out var nonePortColor);
            NonePortColor = nonePortColor;
            ColorUtility.TryParseHtmlString(STRUCT_PORT_COLOR, out var structPortColor);
            StructPortColor = structPortColor;
            ColorUtility.TryParseHtmlString(PRIMITIVE_PORT_COLOR, out var primitivePortColor);
            PrimitivePortColor = primitivePortColor;
            ColorUtility.TryParseHtmlString(UNITY_MONO_BEHAVIOUR_PORT_COLOR, out var unityMonoBehaviourPortColor);
            UnityMonoBehaviourPortColor = unityMonoBehaviourPortColor;
            ColorUtility.TryParseHtmlString(UNITY_SCRIPTABLE_OBJECT_PORT_COLOR, out var unityScriptableObjectPortColor);
            UnityScriptableObjectPortColor = unityScriptableObjectPortColor;
            ColorUtility.TryParseHtmlString(SELECTION_COLOR, out var selectionColor);
            SelectionColor = selectionColor;
            StickyNoteFont = true;
            
            JungleIconCache.instance.BuildIconCache();
        }
        
        // Validation ---------------------------------------------------------------------------------------------------
        
        internal static bool RefreshValidationInPlayMode
        {
            get => EditorPrefs.GetBool("Jungle.RefreshValidationInPlayMode", false);
            set => EditorPrefs.SetBool("Jungle.RefreshValidationInPlayMode", value);
        }
        
        internal static bool RefreshDuringBuild
        {
            get => EditorPrefs.GetBool("Jungle.RefreshDuringBuild", true);
            set => EditorPrefs.SetBool("Jungle.RefreshDuringBuild", value);
        }
        
        // Validation --------------------------------------------------------------------------------------------------
        
        // Cache -------------------------------------------------------------------------------------------------------
        
        internal static bool UseCaching
        {
            get => EditorPrefs.GetBool("Jungle.UseCaching", true);
            set => EditorPrefs.SetBool("Jungle.UseCaching", value);
        }
        
        internal static int MaxCacheSize
        {
            get => EditorPrefs.GetInt("Jungle.MaxCacheSize", 32);
            set => EditorPrefs.SetInt("Jungle.MaxCacheSize", value);
        }
        
        // Cache -------------------------------------------------------------------------------------------------------
        
        // Appearance --------------------------------------------------------------------------------------------------

        internal static Color SelectionColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.SelectionColor",
                    SELECTION_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.SelectionColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }
        
        internal static bool StickyNoteFont
        {
            get => EditorPrefs.GetBool("Jungle.StickyNoteFont", true);
            set => EditorPrefs.SetBool("Jungle.StickyNoteFont", value);
        }
        
        internal static Color NonePortColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.NonePortColor",
                    NONE_PORT_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.NonePortColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }
        
        internal static Color StructPortColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.StructPortColor",
                    STRUCT_PORT_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.StructPortColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }
        
        internal static Color PrimitivePortColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.PrimitivePortColor",
                    PRIMITIVE_PORT_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.PrimitivePortColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }

        internal static Color UnityMonoBehaviourPortColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.UnityMonoBehaviourPortColor",
                    UNITY_MONO_BEHAVIOUR_PORT_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.UnityMonoBehaviourPortColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }
        
        internal static Color UnityScriptableObjectPortColor
        {
            get
            {
                var hexColor = EditorPrefs.GetString
                (
                    "Jungle.UnityScriptableObjectPortColor",
                    UNITY_SCRIPTABLE_OBJECT_PORT_COLOR
                );
                ColorUtility.TryParseHtmlString(hexColor, out var color);
                return color;
            }
            set => EditorPrefs.SetString("Jungle.UnityScriptableObjectPortColor", $"#{ColorUtility.ToHtmlStringRGBA(value)}");
        }
        
        // Miscellaneous -----------------------------------------------------------------------------------------------
        
        internal static string Signature
        {
            get => EditorPrefs.GetString("Jungle.Signature", string.Empty);
            set => EditorPrefs.SetString("Jungle.Signature", value);
        }
        
        // Miscellaneous -----------------------------------------------------------------------------------------------
    }
}

using UnityEditor;
using UnityEngine;

namespace Jungle.Editor
{
    internal static class JungleSplash
    {
        private static bool ShowSplashPrompt()
        {
            var hasShownSplashPrompt = EditorPrefs.GetBool("Jungle.HasShownSplashPrompt", false);
            if (!hasShownSplashPrompt)
                EditorPrefs.SetBool("Jungle.HasShownSplashPrompt", true);
            return !hasShownSplashPrompt;
        }
        
        [InitializeOnLoadMethod]
        private static void InitializeOnLoadCallback()
        {
            if (!ShowSplashPrompt())
                return;
            
            EditorUtility.DisplayDialog
            (
                "Jungle - Terms and Conditions",
                "By using Jungle, you agree to the Terms and Conditions as described in the \"LICENSE.md\" file.\n" + 
                "jackedupsoftware.com/legal/terms-and-conditions",
                "Accept"
            );
            
            JungleSignatureEditor.Open();
        }
    }
    
    internal class JungleSignatureEditor : EditorWindow
    {
        private string _signature;
        
        internal static void Open()
        {
            var window = GetWindow<JungleSignatureEditor>(true, "Jungle - Enter Your Signature", true);
            window.minSize = new Vector2(400f, 100f);
            window.maxSize = new Vector2(400f, 100f);
        }
        

        private void OnEnable()
        {
            _signature = JunglePreferencesUtility.Signature;
        }

        private void OnGUI()
        {
            GUILayout.Label
            (
                "Enter your name/signature to sign all trees, nodes, and notes you create.\n" +
                "Signatures helps you know who made what and when!",
                EditorStyles.wordWrappedLabel
            );
            
            GUILayout.Space(10);
            UnityEngine.GUI.enabled = false;
            GUILayout.Label("Ex. John Doe", EditorStyles.miniLabel);
            UnityEngine.GUI.enabled = true;
            
            GUILayout.BeginHorizontal();
                _signature = GUILayout.TextField(_signature, GUILayout.Width(215f));
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Save and Close"))
                {
                    JunglePreferencesUtility.Signature = _signature;
                    Close();
                }
                GUILayout.Space(2f);
            GUILayout.EndHorizontal();
            
        }
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Jungle.Editor
{
    internal class JungleValidator : EditorWindow
    {
        private const float MIN_WINDOW_WIDTH = 250f;
        private const float MIN_WINDOW_HEIGHT = 250f;
        
        private string SearchFilter
        {
            get => _searchFilter ??= EditorPrefs.GetString
            (
                "Jungle.ValidatorSearchFilter",
                string.Empty
            );
            set => EditorPrefs.SetString
            (
                "Jungle.ValidatorSearchFilter",
                _searchFilter = value
            );
        }
        private string _searchFilter = null;
        
        private int OpenedItemIndex
        {
            get
            {
                if (_openedItemIndex == -1)
                {
                    _openedItemIndex = EditorPrefs.GetInt("Jungle.ValidatorOpenedItemIndex", 0);
                }
                return _openedItemIndex;
            }
            set => EditorPrefs.SetInt("Jungle.ValidatorOpenedItemIndex", _openedItemIndex = value);
        }
        private int _openedItemIndex = -1;
        
        private Vector2 _scrollPosition;
        private bool _highlightOnlyNodes;
        private List<IssuesContainer> _allIssues;
        private List<IssuesContainer> _queriedIssues;
        
        private readonly struct IssuesContainer
        {
            internal readonly JungleTree JungleTree;
            internal readonly IssueItem[] Issues;
            
            internal IssuesContainer(JungleTree jungleTree, IssueItem[] issues)
            {
                JungleTree = jungleTree;
                Issues = issues;
            }
            
            internal bool MatchesSearch(string searchFilter)
            {
                return FormatSearch(JungleTree.name).Contains(FormatSearch(searchFilter));
            }
            
            internal static string FormatSearch(string term)
            {
                return term.ToLower().Trim().Replace(" ", string.Empty);
            }
        }
        
        private readonly struct IssueItem
        {
            internal readonly JungleNode JungleNode;
            internal readonly string[] JungleNodeIssues;
            
            internal IssueItem(JungleNode jungleNode, string[] jungleNodeIssues)
            {
                JungleNode = jungleNode;
                JungleNodeIssues = jungleNodeIssues;
            }
            
            internal bool MatchesSearch(string searchFilter)
            {
                var formattedSearchFilter = IssuesContainer.FormatSearch(searchFilter);
                
                // Check if search matches Uid EXACTLY
                if (IssuesContainer.FormatSearch(JungleNode.Uid) == formattedSearchFilter)
                    return true;
                
                return IssuesContainer.FormatSearch(JungleNode.name).Contains(formattedSearchFilter);
            }
        }
        
        [MenuItem("Jungle/Validator/Open", priority = 2)]
        private static void OpenWindow()
        {
            JungleValidatorUtility.PerformSoftValidationPass();
            GetWindow<JungleValidator>();
        }
        
        public static void OpenWindow(string search)
        {
            JungleValidatorUtility.PerformSoftValidationPass();
            var window = GetWindow<JungleValidator>();
            window.SearchFilter = search;
            window.RebuildQuery();
        }
        
        private void OnEnable()
        {
            titleContent = new GUIContent
            (
                "Jungle Validator", 
                Resources.Load<Texture2D>
                (
                    EditorGUIUtility.isProSkin
                        ? "d_JungleValidatorIcon"
                        : "JungleValidatorIcon"
                )
            );
            minSize = new Vector2(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT);
            RebuildQuery();
        }
        
        private void OnGUI()
        {
            DrawHeader();
            DrawBody();
            DrawFooter();
        }

        private void DrawHeader()
        {
            GUILayout.BeginHorizontal(EditorStyles.toolbar);
                var refreshIcon = EditorGUIUtility.IconContent("Refresh");
                if (GUILayout.Button(refreshIcon, EditorStyles.toolbarButton, GUILayout.Width(32f)))
                {
                    JungleValidatorUtility.PerformSoftValidationPass();
                    RebuildQuery();
                }
                GUILayout.Space(2f);
                var newSearch = GUILayout.TextField
                (
                    SearchFilter,
                    EditorStyles.toolbarSearchField,
                    GUILayout.MaxWidth(350f)
                );
                if (SearchFilter != newSearch)
                {
                    SearchFilter = newSearch;
                    RebuildQuery();
                }
                GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
        }
        
        private void DrawBody()
        {
            if (_queriedIssues.Any(issue => issue.JungleTree == null))
            {
                JungleValidatorUtility.PerformSoftValidationPass();
                RebuildQuery();
            }
            
            if (_allIssues.Count == 0)
            {
                GUILayout.Space(10f);
                GUILayout.BeginHorizontal();
                    GUILayout.FlexibleSpace();
                    GUILayout.Label("Hooray! No issues found.", EditorStyles.boldLabel);
                    GUILayout.FlexibleSpace();
                GUILayout.EndHorizontal();
                return;
            }
            if (_queriedIssues.Count == 0)
            {
                GUILayout.Space(10f);
                GUILayout.BeginHorizontal();
                    GUILayout.FlexibleSpace();
                    GUILayout.Label("No results found.", EditorStyles.boldLabel);
                    GUILayout.FlexibleSpace();
                GUILayout.EndHorizontal();
                return;
            }
            
            _scrollPosition = GUILayout.BeginScrollView(_scrollPosition);
                foreach (var issue in _queriedIssues)
                {
                    var issueIndex = _queriedIssues.IndexOf(issue);
                    var issueOpened = issueIndex == OpenedItemIndex;
                    
                    if (!_highlightOnlyNodes && !string.IsNullOrEmpty(SearchFilter.Trim()))
                        UnityEngine.GUI.color = Color.yellow;
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                        GUILayout.BeginHorizontal();
                            var foldoutState = EditorGUILayout.Foldout(issueOpened, issue.JungleTree.name);
                            if (foldoutState != issueOpened && foldoutState)
                                OpenedItemIndex = issueIndex;
                            GUILayout.FlexibleSpace();
                            if (GUILayout.Button(EditorGUIUtility.IconContent("scenepicking_pickable_hover")))
                            {
                                Selection.activeObject = issue.JungleTree;
                                EditorGUIUtility.PingObject(issue.JungleTree);
                            }
                        GUILayout.EndHorizontal();
                        GUILayout.Space(3f);
                        
                        if (foldoutState)
                        {
                            foreach (var issueItem in issue.Issues)
                            {
                                var highlight = _highlightOnlyNodes &&
                                                !string.IsNullOrEmpty(SearchFilter.Trim()) &&
                                                issueItem.MatchesSearch(SearchFilter);
                                
                                UnityEngine.GUI.color = highlight 
                                    ? Color.yellow 
                                    : Color.white;
                                
                                GUILayout.BeginVertical(EditorStyles.helpBox);
                                    GUILayout.BeginHorizontal();
                                        UnityEngine.GUI.color = Color.white;
                                        var iconRect = GUILayoutUtility.GetRect
                                        (
                                            GUIContent.none,
                                            GUIStyle.none,
                                            GUILayout.Height(24f),
                                            GUILayout.Width(24f)
                                        );
                                        UnityEngine.GUI.DrawTexture(iconRect, issueItem.JungleNode.GetIcon());
                                        
                                        if (highlight)
                                            UnityEngine.GUI.color = Color.yellow;
                                        
                                        GUILayout.BeginVertical();
                                            GUILayout.Space(5f);
                                            GUILayout.Label(issueItem.JungleNode.name, EditorStyles.boldLabel);
                                        GUILayout.EndVertical();
                                    GUILayout.EndHorizontal();
                                    
                                    foreach (var issueMessage in issueItem.JungleNodeIssues)
                                    {
                                        GUILayout.Label($"• {issueMessage}", EditorStyles.wordWrappedLabel);
                                    }
                                GUILayout.EndVertical();
                            }
                        }
                    GUILayout.EndVertical();
                    UnityEngine.GUI.color = Color.white;
                }
            GUILayout.EndScrollView();
        }
        
        private void DrawFooter()
        {
            GUILayout.FlexibleSpace();
            GUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                GUILayout.Label
                (
                    $"Last Validated at {JungleValidatorUtility.LastValidationTime}",
                    EditorStyles.wordWrappedMiniLabel
                );
                GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();
        }
        
        private void RebuildQuery()
        {
            _allIssues = JungleValidatorUtility.Issues.ToList().ConvertAll(issue =>
            {
                var issueItems = new List<IssueItem>();
                foreach (var nodeIssue in issue.Value)
                {
                    issueItems.Add(new IssueItem(nodeIssue.Key, nodeIssue.Value));
                }
                return new IssuesContainer(issue.Key, issueItems.ToArray());
            });
            _queriedIssues = new List<IssuesContainer>();
            
            if (OpenedItemIndex == -1 && _allIssues.Count > 0)
                OpenedItemIndex = 0;
            
            if (string.IsNullOrEmpty(SearchFilter.Trim()))
            {
                _queriedIssues = _allIssues;
                _highlightOnlyNodes = false;
                return;
            }
            
            var treeQuery = new List<IssuesContainer>(_allIssues);
            treeQuery.RemoveAll(issue =>
            {
                return !issue.MatchesSearch(IssuesContainer.FormatSearch(SearchFilter));
            });
            
            if (treeQuery.Count > 0)
            {
                _highlightOnlyNodes = false;
                _queriedIssues = treeQuery;
                return;
            }
            
            var nodesQuery = new List<IssuesContainer>(_allIssues);
            nodesQuery.RemoveAll(issue =>
            {
                return !issue.Issues.Any(nodeIssue => nodeIssue.MatchesSearch(SearchFilter));
            });
            
            if (nodesQuery.Count > 0)
            {
                _highlightOnlyNodes = true;
                _queriedIssues = nodesQuery;
            }
        }
    }
    
    internal static class JungleValidatorUtility
    {
        internal static Dictionary<JungleTree, Dictionary<JungleNode, string[]>> Issues
        {
            get;
            private set;
        }
        
        internal static string LastValidationTime
        {
            get => _lastValidationTime ??= EditorPrefs.GetString
            (
                "Jungle.LastValidationTime",
                "Never"
            );
            private set => EditorPrefs.SetString
            (
                "Jungle.LastValidationTime",
                _lastValidationTime = value
            );
        }
        private static string _lastValidationTime = null;
        
        [InitializeOnLoadMethod]
        private static void InitializeOnLoadCallback()
        {
            PerformCutThroatValidation();
            PerformSoftValidationPass();
        }
        
        internal static void PerformCutThroatValidation()
        {
            var issueCount = 0;
            
            foreach (var jungleTree in JungleTreeCache.GetAllJungleTrees())
            {
                //var nodeIssues = jungleTree.RemoveAllMissingNodes();
                //var portIssues = jungleTree.RemoveAllConnectionMismatches();
                //issueCount += nodeIssues + portIssues;
            }
            
            if (issueCount == 0)
                return;
            
            Debug.LogFormat
            (
                LogType.Error, LogOption.NoStacktrace, null,
                "[<b>Jungle</b>] > [<b>Validator</b>] Some critical issues were found while performing " +
                "validation pass.\n" +
                "<b>Click for more information</b>" +
                "\n\n" +
                "Affected Jungle Tree(s):" +
                "..."
            );
            
            // Save the time of this validation pass
            LastValidationTime = DateTime.Now.ToShortTimeString();
        }
        
        internal static void PerformSoftValidationPass()
        {
            Issues = new Dictionary<JungleTree, Dictionary<JungleNode, string[]>>();
            foreach (var jungleTree in JungleTreeCache.GetAllJungleTrees())
            {
                var nodeIssues = new Dictionary<JungleNode, string[]>();
                
                foreach (var node in jungleTree.Nodes)
                {
                    var issues = node.Validate();
                    if (issues.Length == 0) 
                        continue;
                    nodeIssues.Add(node, issues);
                }
                
                if (nodeIssues.Count == 0) 
                    continue;
                Issues.Add(jungleTree, nodeIssues);
            }
            
            // Save the time of this validation pass
            LastValidationTime = DateTime.Now.ToShortTimeString();
        }
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Jungle
{
    /// <summary>
    /// A Jungle Node type designed to accept a value and ability to call multiple outputs with different value types.
    /// </summary>
    [Serializable] [BranchNode]
    public abstract class BranchNode<T> : JungleNode
    {
        public override Port.Info GetInputPortInfo()
        {
            var portName = GetInfo().InputPortName ?? string.Empty;
            var portType = typeof(T);
            return new Port.Info(portName, portType);
        }
        
        public override Port.Info[] GetOutputPortsInfo()
        {
            var portNames = GetInfo().OutputPortNames ?? Array.Empty<string>();
            var portTypes = GetInfo().OutputPortTypes ?? Array.Empty<Type>();
            
            if (portNames.Length == portTypes.Length)
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portNames.Length; i++)
                {
                    var portName = portNames[i];
                    var portType = portTypes[i];
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
            
            if (portNames.Length > portTypes.Length)
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portNames.Length; i++)
                {
                    var portName = portNames[i];
                    var portType = portTypes.Length - 1 > i
                        ? portTypes[i]
                        : typeof(Port.Error);
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
            else
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portTypes.Length; i++)
                {
                    var portName = portNames.Length - 1 > i
                        ? portNames[i]
                        : "Unnamed Port";
                    var portType = portTypes[i];
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
        }
        
        private BranchNodeAttribute GetInfo()
        {
            return (BranchNodeAttribute)GetType().GetCustomAttributes(typeof(BranchNodeAttribute), true)[0];
        }
        
        /// <summary>
        /// Invoked immediately when this Branch Node is started.
        /// </summary>
        protected abstract void OnStart(in T inputValue);
        internal override void OnStart_Internal(in object inputValue) => OnStart((T)inputValue);
        
        /// <summary>
        /// Invoked immediately when this Branch Node is stopped.
        /// </summary>
        protected virtual void OnStop() {}
        internal override void OnStop_Internal() => OnStop();
        
        /// <summary>
        /// Invoked every frame while this Branch Node is playing.
        /// </summary>
        protected abstract void OnUpdate();
        internal override void OnUpdate_Internal() => OnUpdate();
        
        /// <summary>
        /// Sends the port calls out to the requested ports.
        /// </summary>
        protected void Call(Port.Call[] portCalls)
        {
            JungleTree.Call_Internal(this, portCalls);
        }
        
        /// <summary>
        /// Sends the port call out to the requested port.
        /// </summary>
        protected void Call(Port.Call portCall)
        {
            JungleTree.Call_Internal(this, new []{ portCall });
        }
        
        /// <summary>
        /// Stops this Branch Node without sending out any port calls.
        /// </summary>
        protected void Stop()
        {
            JungleTree.CallAndStop_Internal(this, null);
        }
        
        /// <summary>
        /// Both sends the port calls out to the requested ports and stops this Branch Node.
        /// </summary>
        protected void CallAndStop(Port.Call[] portCalls)
        {
            JungleTree.CallAndStop_Internal(this, portCalls);
        }
        
        /// <summary>
        /// Both sends the port call out to the requested port and stops this Branch Node.
        /// </summary>
        protected void CallAndStop(Port.Call portCall)
        {
            JungleTree.CallAndStop_Internal(this, new []
            {
                portCall
            });
        }
        
        /// <summary>
        /// Invoked whenever a validation pass is made on this Branch Node.
        /// </summary>
        /// <returns>List of issues found on this Branch Node.</returns>
        protected virtual string[] OnValidation()
        {
            return Array.Empty<string>();
        }
        internal override string[] OnValidation_Internal()
        {
            var inheritedIssues = OnValidation() ?? Array.Empty<string>();
            
            var internalIssues = new List<string>();
            if (GetInfo().OutputPortNames.Length > GetInfo().OutputPortTypes.Length)
                internalIssues.Add("There are more output port names declared than output port types.");
            else if (GetInfo().OutputPortNames.Length < GetInfo().OutputPortTypes.Length)
                internalIssues.Add("There are more output port types declared than output port names.");
            
            var nodeIssues = new List<string>(inheritedIssues).Concat(internalIssues).ToArray();
            return nodeIssues;
        }
        
        internal override void OnConnection_Internal(Port affectedPort, JungleNode connected) { }
        
        internal override void OnDisconnection_Internal(Port affectedPort, JungleNode disconnected) { }
    }
    
    /// <summary>
    /// Branch node info attribute. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class BranchNodeAttribute : Attribute
    {
        /// <summary>
        /// Name of the input port.
        /// </summary>
        public string InputPortName
        {
            get;
            set;
        } = "Execute"; 
        
        /// <summary>
        /// Names to correspond with each output port.
        /// </summary>
        public string[] OutputPortNames
        {
            get;
            set;
        } = { "Next" };
        
        /// <summary>
        /// Output value types to correspond with each output port.
        /// </summary>
        public Type[] OutputPortTypes
        {
            get;
            set;
        } = { typeof(Port.None) };
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Jungle
{
    /// <summary>
    /// A Jungle Node type designed for event calls. This node type takes no input, and is started automatically
    /// at the start of the Jungle Tree.
    /// </summary>
    [Serializable] [EventNode]
    public abstract class EventNode : JungleNode
    {
        public override Port.Info GetInputPortInfo()
        {
            return new Port.Info();
        }
        
        public override Port.Info[] GetOutputPortsInfo()
        {
            var portNames = GetInfo().OutputPortNames ?? Array.Empty<string>();
            var portTypes = GetInfo().OutputPortTypes ?? Array.Empty<Type>();
            
            if (portNames.Length == portTypes.Length)
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portNames.Length; i++)
                {
                    var portName = portNames[i];
                    var portType = portTypes[i];
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
            
            if (portNames.Length > portTypes.Length)
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portNames.Length; i++)
                {
                    var portName = portNames[i];
                    var portType = portTypes.Length - 1 > i
                        ? portTypes[i]
                        : typeof(Port.Error);
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
            else
            {
                var portQuery = new List<Port.Info>();
                for (var i = 0; i < portTypes.Length; i++)
                {
                    var portName = portNames.Length - 1 > i
                        ? portNames[i]
                        : "Unnamed Port";
                    var portType = portTypes[i];
                    portQuery.Add(new Port.Info(portName, portType));
                }
                return portQuery.ToArray();
            }
        }
        
        private EventNodeAttribute GetInfo()
        {
            return (EventNodeAttribute) GetType().GetCustomAttributes(typeof(EventNodeAttribute), true)[0];
        }
        
        /// <summary>
        /// Invoked immediately when this Event Node is started.
        /// </summary>
        protected abstract void OnStart();
        internal override void OnStart_Internal(in object inputValue) => OnStart();
        
        /// <summary>
        /// Invoked immediately when this Event Node is stopped.
        /// </summary>
        protected virtual void OnStop() {}
        internal override void OnStop_Internal() => OnStop();
        
        /// <summary>
        /// Invoked every frame while this Event Node is playing.
        /// </summary>
        protected abstract void OnUpdate();
        internal override void OnUpdate_Internal() => OnUpdate();
        
        /// <summary>
        /// Sends out port calls.
        /// </summary>
        protected void Call(Port.Call[] portCalls)
        {
            JungleTree.Call_Internal(this, portCalls);
        }
        
        /// <summary>
        /// Sends out a port call.
        /// </summary>
        protected void Call(Port.Call portCall)
        {
            JungleTree.Call_Internal(this, new []{ portCall });
        }
        
        /// <summary>
        /// Stops this Event Node without sending port calls.
        /// </summary>
        protected void Stop()
        {
            JungleTree.CallAndStop_Internal(this, null);
        }
        
        /// <summary>
        /// Sends out port calls and then stops this Event Node.
        /// </summary>
        protected void CallAndStop(Port.Call[] portCalls)
        {
            JungleTree.CallAndStop_Internal(this, portCalls);
        }
        
        /// <summary>
        /// Sends out a port call and then stops this Event Node.
        /// </summary>
        protected void CallAndStop(Port.Call portCall)
        {
            JungleTree.CallAndStop_Internal(this, new []
            {
                portCall
            });
        }
        
        /// <summary>
        /// Invoked whenever a validation pass is made.
        /// </summary>
        /// <returns>List of validation issues.</returns>
        protected virtual string[] OnValidation()
        {
            return Array.Empty<string>();
        }
        internal override string[] OnValidation_Internal()
        {
            var inheritedIssues = OnValidation() ?? Array.Empty<string>();
            
            var internalIssues = new List<string>();
            if (GetInfo().OutputPortNames.Length > GetInfo().OutputPortTypes.Length)
                internalIssues.Add("There are more output port names declared than output port types.");
            else if (GetInfo().OutputPortNames.Length < GetInfo().OutputPortTypes.Length)
                internalIssues.Add("There are more output port types declared than output port names.");
            
            var nodeIssues = new List<string>(inheritedIssues).Concat(internalIssues).ToArray();
            return nodeIssues;
        }
        
        internal override void OnConnection_Internal(Port affectedPort, JungleNode connected) { }
        
        internal override void OnDisconnection_Internal(Port affectedPort, JungleNode disconnected) { }
    }
    
    /// <summary>
    /// Event node info attribute. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class EventNodeAttribute : Attribute
    {
        /// <summary>
        /// Names to correspond with each output port.
        /// </summary>
        public string[] OutputPortNames
        {
            get;
            set;
        } =
        {
            "Call"
        };
        
        /// <summary>
        /// Output value types to correspond with each output port.
        /// </summary>
        public Type[] OutputPortTypes
        {
            get;
            set;
        } =
        {
            typeof(Port.None)
        };
    }
}

﻿using System;
using UnityEngine;

namespace Jungle
{
    /// <summary>
    /// A Jungle Node type designed to accept a single input of any type (called an Generic) and call the value to all
    /// connected members without mutating the value in any way. The accepted type is determined by the input connection
    /// rather than the manifest. 
    /// </summary>
    [Serializable] [GenericNode]
    public abstract class GenericNode : JungleNode
    {
        [SerializeField] [HideInInspector]
        private string genericTypeAssemblyName;
        
        [NonSerialized]
        private object _generic;
        
        public override Port.Info GetInputPortInfo()
        {
            var portName = GetInfo().InputPortName ?? string.Empty;
            var portType = string.IsNullOrEmpty(genericTypeAssemblyName)
                ? typeof(Port.NA)
                : Type.GetType(genericTypeAssemblyName);
            return new Port.Info(portName, portType);
        }
        
        public override Port.Info[] GetOutputPortsInfo()
        {
            var portName = GetInfo().OutputPortName ?? string.Empty;
            return new[]
            {
                new Port.Info(portName, GetInputPortInfo().Type)
            };
        }
        
        private GenericNodeAttribute GetInfo()
        {
            return (GenericNodeAttribute)GetType().GetCustomAttributes(typeof(GenericNodeAttribute), true)[0];
        }
        
        /// <summary>
        /// Invoked immediately when this Generic Node is started.
        /// </summary>
        protected abstract void OnStart();
        internal override void OnStart_Internal(in object inputValue)
        {
            _generic = inputValue;
            OnStart();
        }
        
        /// <summary>
        /// Invoked immediately when this Generic Node is stopped.
        /// </summary>
        protected virtual void OnStop() {}
        internal override void OnStop_Internal() => OnStop();
        
        /// <summary>
        /// Invoked every frame while this Generic Node is playing.
        /// </summary>
        protected abstract void OnUpdate();
        internal override void OnUpdate_Internal() => OnUpdate();
        
        /// <summary>
        /// Sends out port calls.
        /// </summary>
        protected void Call()
        {
            JungleTree.Call_Internal(this, new[]
            {
                new Port.Call(0, _generic)
            });
        }
        
        /// <summary>
        /// Stops this Generic Node and doesn't send any port calls.
        /// </summary>
        protected void Stop()
        {
            JungleTree.CallAndStop_Internal(this, null);
            _generic = null;
        }
        
        /// <summary>
        /// Sends out port calls and then stops this Generic Node.
        /// </summary>
        protected void CallAndStop()
        {
            JungleTree.CallAndStop_Internal(this, new[]
            {
                new Port.Call(0, _generic)
            });
            _generic = null;
        }
        
        /// <summary>
        /// Invoked whenever a validation pass is made.
        /// </summary>
        /// <returns>List of validation issues.</returns>
        protected virtual string[] OnValidation()
        {
            return Array.Empty<string>();
        }
        internal override string[] OnValidation_Internal()
        {
            return OnValidation() ?? Array.Empty<string>();
        }
        
        internal override void OnConnection_Internal(Port affectedPort, JungleNode connected)
        {
            genericTypeAssemblyName = affectedPort.GetPortOutputType().AssemblyQualifiedName;
        }
        
        internal override void OnDisconnection_Internal(Port affectedPort, JungleNode disconnected)
        {
            if (affectedPort.JungleNode == this)
                return;
            genericTypeAssemblyName = null;
#if UNITY_EDITOR
            RemoveAllOutputConnections_Internal();
#endif
        }
    }
    
    /// <summary>
    /// Generic node info attribute. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class GenericNodeAttribute : Attribute
    {
        /// <summary>
        /// The name of the input port.
        /// </summary>
        public string InputPortName
        {
            get; 
            set;
        } = "Execute";
        
        /// <summary>
        /// The name of the output port.
        /// </summary>
        public string OutputPortName
        {
            get; 
            set;
        } = "Next";
    }
}

﻿using System;

namespace Jungle
{
    /// <summary>
    /// A Jungle Node type designed to accept a single input and produce a single output.
    /// </summary>
    [Serializable] [IONode]
    public abstract class IONode<T> : JungleNode
    {
        public override Port.Info GetInputPortInfo()
        {
            var portName = GetInfo().InputPortName ?? string.Empty;
            var portType = typeof(T);
            return new Port.Info(portName, portType);
        }
        
        public override Port.Info[] GetOutputPortsInfo()
        {
            var portName = GetInfo().OutputPortName ?? string.Empty;
            var portType = GetInfo().OutputPortType ?? typeof(Port.None);
            return new[]
            {
                new Port.Info(portName, portType)
            };
        }
        
        private IONodeAttribute GetInfo()
        {
            return (IONodeAttribute)GetType().GetCustomAttributes(typeof(IONodeAttribute), true)[0];
        }
        
        /// <summary>
        /// Invoked immediately when this IO Node is started.
        /// </summary>
        protected abstract void OnStart(in T inputValue);
        internal override void OnStart_Internal(in object inputValue) => OnStart((T)inputValue);
        
        /// <summary>
        /// Invoked immediately when this IO Node is stopped.
        /// </summary>
        protected virtual void OnStop() {}
        internal override void OnStop_Internal() => OnStop();
        
        /// <summary>
        /// Invoked every frame while this IO Node is playing.
        /// </summary>
        protected abstract void OnUpdate();
        internal override void OnUpdate_Internal() => OnUpdate();
        
        /// <summary>
        /// Sends out port calls.
        /// </summary>
        /// <param name="output">The data to send in the port calls.</param>
        protected void Call(object output)
        {
            JungleTree.Call_Internal(this, new []
            {
                new Port.Call(0, output)
            });
        }
        
        /// <summary>
        /// Stops this IO Node and doesn't send any port calls.
        /// </summary>
        protected void Stop()
        {
            JungleTree.CallAndStop_Internal(this, null);
        }
        
        /// <summary>
        /// Sends out port calls and then stops this IO Node.
        /// </summary>
        /// <param name="output">The data to send in the port calls.</param>
        protected void CallAndStop(object output)
        {
            JungleTree.CallAndStop_Internal(this, new []
            {
                new Port.Call(0, output)
            });
        }
        
        /// <summary>
        /// Invoked whenever a validation pass is made.
        /// </summary>
        /// <returns>List of validation issues.</returns>
        protected virtual string[] OnValidation()
        {
            return Array.Empty<string>();
        }
        internal override string[] OnValidation_Internal()
        {
            var issues = OnValidation() ?? Array.Empty<string>();
            return issues;
        }
        
        internal override void OnConnection_Internal(Port affectedPort, JungleNode connected) { }
        
        internal override void OnDisconnection_Internal(Port affectedPort, JungleNode disconnected) { }
    }
    
    /// <summary>
    /// Identity node info attribute. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class IONodeAttribute : Attribute
    {
        /// <summary>
        /// The name of the input port.
        /// </summary>
        public string InputPortName
        {
            get; 
            set;
        } = "Execute";
        
        /// <summary>
        /// The name of the output port.
        /// </summary>
        public string OutputPortName
        {
            get; 
            set;
        } = "Next";
        
        /// <summary>
        /// The output port type.
        /// </summary>
        public Type OutputPortType
        {
            get; 
            set;
        } = typeof(Port.None);
    }
}

﻿#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using Jungle.Nodes;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Jungle
{
    /// <summary>
    /// Cache for storing Jungle Node icons.
    /// *Editor Only*
    /// </summary>
    [FilePath("JungleIcon.cache", FilePathAttribute.Location.ProjectFolder)]
    public class JungleIconCache : ScriptableSingleton<JungleIconCache>
    {
        #region Properties

        [SerializeField] 
        private List<IconContainer> cache = new();
        
        [SerializeField]
        private List<JungleTree> jungleTrees = new();
        
        [Serializable]
        private struct IconContainer
        {
            [SerializeField]
            private List<string> types;
            [SerializeField]
            private Texture icon;
            
            internal IconContainer(List<Type> types, Texture icon)
            {
                types ??= new List<Type>();
                this.types = types.ConvertAll(type => type.AssemblyQualifiedName);
                this.icon = icon;
            }
            
            internal Texture GetIcon()
            {
                return icon;
            }
            
            internal int GetIconInstanceID()
            {
                return icon.GetInstanceID();
            }
            
            internal bool HasType(Type type)
            {
                types ??= new List<string>();
                return types.Contains(type.AssemblyQualifiedName);
            }
            
            internal void AddType(Type type)
            {
                types ??= new List<string>();
                if (!types.Contains(type.AssemblyQualifiedName))
                    types.Add(type.AssemblyQualifiedName);
            }
            
            internal void RemoveType(Type type)
            {
                types ??= new List<string>();
                if (types.Contains(type.AssemblyQualifiedName))
                    types.Remove(type.AssemblyQualifiedName);
            }
        }
        
        #endregion
        
        private void OnEnable()
        {
            if (!EditorPrefs.GetBool("Jungle.UseCaching", true))
                return;
            BuildIconCache();
        }

        /// <summary>
        /// Builds the Jungle Cache.
        /// </summary>
        public void BuildIconCache()
        {
            cache ??= new List<IconContainer>();
            
            var jungleNodeTypes = TypeCache.GetTypesDerivedFrom<JungleNode>().ToList();
            jungleNodeTypes = jungleNodeTypes.FindAll(jungleNodeType => !jungleNodeType.IsAbstract);

            var iterations = 0;
            var maxCacheSize = GetMaxCacheSize();
            
            var addIconInstanceIDs = new List<int>();
            
            foreach (var type in jungleNodeTypes)
            {
                // If the cache is full, stop
                if (iterations > maxCacheSize)
                    break;
                
                var typeIcon = GetTypeThumbnail(type);
                
                // Remove any types that might already exist in the cache
                // *Only is the icon is different from the one already in the cache
                if (cache.Any(container => container.HasType(type)))
                {
                    var cacheToRemoveTypeFrom = cache.Find(container => container.HasType(type));
                    if (cacheToRemoveTypeFrom.GetIconInstanceID() != typeIcon.GetInstanceID())
                        cacheToRemoveTypeFrom.RemoveType(type);
                }
                
                // If the icon already exists in the cache, only add the type to it
                if (cache.Any(container => container.GetIconInstanceID() == typeIcon.GetInstanceID()))
                {
                    var cacheToAddTypeTo = cache.Find(container => container.GetIconInstanceID() == typeIcon.GetInstanceID());
                    cacheToAddTypeTo.AddType(type);
                    continue;
                }
                
                cache.Add(new IconContainer
                (
                    new List<Type> { type },
                    typeIcon
                ));
                addIconInstanceIDs.Add(typeIcon.GetInstanceID());
                iterations++;
            }
            
            // Remove any icons that are no longer in use
            cache.RemoveAll(container => !addIconInstanceIDs.Contains(container.GetIconInstanceID()));
        }
        
        /// <summary>
        /// Clears the Jungle Cache.
        /// </summary>
        public void ClearIconCache()
        {
            cache ??= new List<IconContainer>();
            cache.Clear();
        }
        
        /// <summary>
        /// Fetches a types icon from the icon cache.
        /// *If the requested type could not be found in the icon cache, the icon will instead be loaded directly.
        /// </summary>
        public Texture TryGetIconFromCache(Type type)
        {
            foreach (var container in cache)
            {
                if (!container.HasType(type))
                    continue;
                return container.GetIcon();
            }
            return GetTypeThumbnail(type);
        }
        
        /// <summary>
        /// The amount of allocated icons in the Jungle Cache.
        /// </summary>
        public int GetCacheAllocationSize()
        {
            return cache.Count;
        }
        
        private int GetMaxCacheSize()
        {
            return EditorPrefs.GetInt("Jungle.MaxCacheSize", 32);
        }
        
        private Texture GetTypeThumbnail(Type type)
        {
            var temporaryInstance = CreateInstance(type);
            var icon = AssetPreview.GetMiniThumbnail(temporaryInstance);
            DestroyImmediate(temporaryInstance);
            return icon;
        }
    }
    
    /// <summary>
    /// Cache for storing and managing Jungle Trees.
    /// *Editor Only*
    /// </summary>
    [InitializeOnLoad]
    public class JungleTreeCache : AssetPostprocessor
    {
        /// <summary>
        /// Invoked when a Jungle Tree is deleted.
        /// </summary>
        public static event Action OnJungleTreeDeleted; 
        
        /// <returns>A list of all the Jungle Trees in this project.</returns>
        public static JungleTree[] GetAllJungleTrees()
        {
            return _jungleTrees.ToArray();
        }
        private static List<JungleTree> _jungleTrees = new();
        
        static JungleTreeCache()
        {
            RebuildListOfJungleTrees();

            Undo.undoRedoPerformed += () =>
            {
                RebuildListOfJungleTrees();
                foreach (var jungleTree in GetAllJungleTrees())
                {
                    EditorUtility.SetDirty(jungleTree);
                    AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(jungleTree));
                }
            };
        }
        
        private static void OnPostprocessAllAssets
        (
            string[] importedAssets,
            string[] deletedAssets,
            string[] _, string[] __
        )
        {
            // If any Jungle Trees were deleted, rebuild the list
            if (deletedAssets.Length > 0)
            {
                RebuildListOfJungleTrees();
                OnJungleTreeDeleted?.Invoke();
                return;
            }
            
            // If any Jungle Trees were created, add them to the list
            foreach (var createdAssetPath in importedAssets)
                TryAddJungleTree(createdAssetPath);
        }
        
        private static void RebuildListOfJungleTrees()
        {
            _jungleTrees = new List<JungleTree>();
            foreach (var assetGuid in AssetDatabase.FindAssets($"t:{nameof(JungleTree)}"))
            {
                var assetPath = AssetDatabase.GUIDToAssetPath(assetGuid);
                TryAddJungleTree(assetPath);
            }
        }
        
        private static void TryAddJungleTree(string assetPath)
        {
            var jungleTree = AssetDatabase.LoadAssetAtPath<JungleTree>(assetPath);
            if (jungleTree != null)
            {
                // Rebuild the Jungle Trees meta data
                jungleTree.RebuildNodesList();
                jungleTree.Manifest.RebuildNodeMetaData();
                
                // Check if this Jungle Trees Uid already matches another Jungle Tree
                if (_jungleTrees.Any(tree => tree != jungleTree && tree.Uid == jungleTree.Uid))
                {
                    // If so, generate a new Uid for the new Jungle Tree
                    jungleTree.Uid = Guid.NewGuid().ToString();
                    jungleTree.Manifest.RegenerateAllNodeUids();
                }
                
                // Add the Jungle Tree to the list
                _jungleTrees ??= new List<JungleTree>();
                if (!_jungleTrees.Contains(jungleTree))
                {
                    // Generate a new Uid for the Jungle Tree if it doesn't have one
                    if (string.IsNullOrEmpty(jungleTree.Uid))
                        jungleTree.Uid = Guid.NewGuid().ToString();

                    // This ensures the manifest is initialized
                    jungleTree.MakeSureManifestIsInitialized();
                    
                    // Ensure Jungle Tree has a start node
                    if (jungleTree.Nodes == null || jungleTree.Nodes.Length == 0)
                        jungleTree.AddNode(typeof(StartNode), new Vector2(120f, 120f));
                    
                    jungleTree.description ??= $"We don't know much about {jungleTree.name} but we're sure it's great!";
                    _jungleTrees.Add(jungleTree);
                }
            }
        }
    }
}
#endif

﻿#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Jungle
{
    /// <summary>
    /// Jungle manifest container. Saves data about a Jungle Tree inside a sub-object.
    /// </summary>
    [Serializable]
    public class JungleManifest : ScriptableObject
    {
        /// <summary>
        /// The Jungle Tree this manifest belongs to.
        /// </summary>
        public JungleTree JungleTree
        {
            get => jungleTree;
            internal set => jungleTree = value;
        }
        [SerializeField] [HideInInspector]
        private JungleTree jungleTree;
        
        /// <summary>
        /// The view port position in the Jungle Editor.
        /// </summary>
        public Vector3 ViewPosition
        {
            get => viewPosition;
            set
            {
                Undo.RecordObject(this, "Panned Jungle Editor view");
                viewPosition = value;
                EditorUtility.SetDirty(this);
            }
        }
        [SerializeField] [HideInInspector]
        private Vector3 viewPosition = Vector3.zero;
        
        /// <summary>
        /// The view port zoom scale in the Jungle Editor.
        /// </summary>
        public Vector3 ViewScale
        {
            get => viewScale;
            set
            {
                var currentTime = EditorApplication.timeSinceStartup;
                if (currentTime - _lastScaleChangeTime > 0.5f)
                {
                    Undo.RecordObject(this, "Zoomed Jungle Editor view");
                    _lastScaleChangeTime = currentTime;
                }
                viewScale = value;
                EditorUtility.SetDirty(this);
            }
        }
        [SerializeField] [HideInInspector]
        private Vector3 viewScale = Vector3.one;
        
        /// <summary>
        /// List of all Jungle Nodes meta data.
        /// </summary>
        public JungleNodeManifestItem[] NodeManifest => nodeManifest;
        [SerializeField] //[HideInInspector]
        private JungleNodeManifestItem[] nodeManifest = Array.Empty<JungleNodeManifestItem>();
        
        /// <summary>
        /// List of any Jungle Node meta data that no longer could be matched to a Jungle Node.
        /// </summary>
        public JungleNodeManifestItem[] NodeArchive => nodeArchive;
        [SerializeField] //[HideInInspector]
        private JungleNodeManifestItem[] nodeArchive = Array.Empty<JungleNodeManifestItem>();
        
        public JungleStickyNoteManifestItem[] StickyNoteManifest => stickyNoteManifest;
        [SerializeField] //[HideInInspector]
        private JungleStickyNoteManifestItem[] stickyNoteManifest = Array.Empty<JungleStickyNoteManifestItem>();
        
        private double _lastScaleChangeTime;
        
        /// <summary>
        /// Rebuilds the meta data for all Jungle Nodes in the graph using the Jungle Tree node list.
        /// </summary>
        public void RebuildNodeMetaData()
        {
            var validQuery = new List<JungleNodeManifestItem>(NodeManifest ?? Array.Empty<JungleNodeManifestItem>());
            var archiveQuery = new List<JungleNodeManifestItem>(NodeArchive ?? Array.Empty<JungleNodeManifestItem>());
            
            foreach (var nodeInstance in JungleTree.Nodes ?? Array.Empty<JungleNode>())
            {
                if (archiveQuery.Any(metaData => metaData.Uid == nodeInstance.Uid))
                {
                    var metaData = archiveQuery.First(metaData => metaData.Uid == nodeInstance.Uid);
                    validQuery.Add(metaData);
                    archiveQuery.Remove(metaData);
                }
                
                if (validQuery.Any(metaData => metaData.Uid == nodeInstance.Uid))
                {
                    var metaData = validQuery.First(metaData => metaData.Uid == nodeInstance.Uid);
                    metaData.UpdateLastKnownItems(nodeInstance);
                }
            }
            
            var missingNodesMetaData = validQuery.FindAll(metaData => JungleTree.Nodes.All(node => node.Uid != metaData.Uid));
            foreach (var metaData in missingNodesMetaData)
            {
                validQuery.Remove(metaData);
                archiveQuery.Add(metaData);
            }
            
            // Rebuild meta data lists
            nodeManifest = validQuery.ToArray();
            nodeArchive = archiveQuery.ToArray();
            EditorUtility.SetDirty(this);
        }
        
        /// <summary>
        /// Regenerates every Jungle Nodes Uid.
        /// </summary>
        public void RegenerateAllNodeUids()
        {
            for (var i = 0; i < jungleTree.Nodes.Length; i++)
            {
                var nodeInstance = jungleTree.Nodes[i];
                nodeManifest[i].Uid = nodeInstance.GenerateNewUid();
            }
            EditorUtility.SetDirty(this);
        }
        
        #region Nodes

        /// <summary>
        /// Updates/creates the meta data for the inputted Jungle Node.
        /// </summary>
        /// <param name="jungleNode">The Jungle Node to create the meta data for.</param>
        /// <param name="graphPosition">The current position of the Jungle Node in the graph view.</param>
        /// <returns>A reference to the Jungle Nodes meta data.</returns>
        public JungleNodeManifestItem UpdateNodeMetaData(JungleNode jungleNode, Vector2 graphPosition)
        {
            if (HasNodeMetaData(jungleNode))
            {
                var nodeMetaData = TryGetNodeMetaData(jungleNode);
                nodeMetaData.GraphPosition = graphPosition;
                nodeManifest[Array.IndexOf(nodeManifest, TryGetNodeMetaData(jungleNode))] = nodeMetaData;
                EditorUtility.SetDirty(this);
                return nodeMetaData;
            }
            
            // Generate new meta data if none exists for the inputted Jungle Node
            var newNodeMetaData = new JungleNodeManifestItem(jungleNode, graphPosition);
            ArrayUtility.Add(ref nodeManifest, newNodeMetaData);
            EditorUtility.SetDirty(this);
            return newNodeMetaData;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="jungleNode"></param>
        public void RemoveNodeMetaData(JungleNode jungleNode)
        {
            if (!HasNodeMetaData(jungleNode)) 
                return;
            
            var nodeMetaData = TryGetNodeMetaData(jungleNode);
            ArrayUtility.Remove(ref nodeManifest, nodeMetaData);
            EditorUtility.SetDirty(this);
        }
        
        /// <summary>
        /// Returns the meta data of the inputted Jungle Node if any is available.
        /// </summary>
        public JungleNodeManifestItem TryGetNodeMetaData(JungleNode jungleNode)
        {
            return Array.Find(nodeManifest, nodeMeta => nodeMeta.Uid == jungleNode.Uid);
        }
        
        /// <summary>
        /// Returns true if the inputted Jungle Node has meta data already created.
        /// </summary>
        public bool HasNodeMetaData(JungleNode jungleNode)
        {
            return Array.Exists(nodeManifest, nodeMeta => nodeMeta.Uid == jungleNode.Uid);
        }

        #endregion
        
        #region Sticky Notes

        /// <summary>
        /// Creates a new Jungle Sticky Note meta data item.
        /// </summary>
        public JungleStickyNoteManifestItem CreateStickyNoteMetaData
        (
            Vector2 graphPosition,
            Vector2 graphSize,
            string content,
            string theme
        )
        {
            var stickyNoteMetaData = new JungleStickyNoteManifestItem
            (
                graphPosition,
                graphSize,
                content,
                theme,
                false
            );
            ArrayUtility.Add(ref stickyNoteManifest, stickyNoteMetaData);
            EditorUtility.SetDirty(this);
            return stickyNoteMetaData;
        }
        
        /// <summary>
        /// Updates the graph position of the sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem UpdateStickyNoteGraphPosition(string uid, Vector2 graphPosition)
        {
            if (HasStickyNoteMetaData(uid))
            {
                var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
                var stickyNoteIndex = Array.IndexOf(stickyNoteManifest, stickyNoteMetaData);
                stickyNoteMetaData.SetGraphPosition(graphPosition);
                stickyNoteManifest[stickyNoteIndex] = stickyNoteMetaData;
                EditorUtility.SetDirty(this);
                return stickyNoteMetaData;
            }
            throw new Exception("No sticky note meta data found with the inputted uid.");
        }
        
        /// <summary>
        /// Updates the graph size of the sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem UpdateStickyNoteGraphSize(string uid, Vector2 graphSize)
        {
            if (HasStickyNoteMetaData(uid))
            {
                var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
                var stickyNoteIndex = Array.IndexOf(stickyNoteManifest, stickyNoteMetaData);
                stickyNoteMetaData.SetGraphSize(graphSize);
                stickyNoteManifest[stickyNoteIndex] = stickyNoteMetaData;
                EditorUtility.SetDirty(this);
                return stickyNoteMetaData;
            }
            throw new Exception("No sticky note meta data found with the inputted uid.");
        }
                
        /// <summary>
        /// Updates the content of the sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem UpdateStickyNoteContent(string uid, string content)
        {
            if (HasStickyNoteMetaData(uid))
            {
                var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
                var stickyNoteIndex = Array.IndexOf(stickyNoteManifest, stickyNoteMetaData);
                stickyNoteMetaData.SetContent(content);
                stickyNoteManifest[stickyNoteIndex] = stickyNoteMetaData;
                EditorUtility.SetDirty(this);
                return stickyNoteMetaData;
            }
            throw new Exception("No sticky note meta data found with the inputted uid.");
        }
                
        /// <summary>
        /// Updates the theme of the sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem UpdateStickyNoteTheme(string uid, string theme)
        {
            if (HasStickyNoteMetaData(uid))
            {
                var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
                var stickyNoteIndex = Array.IndexOf(stickyNoteManifest, stickyNoteMetaData);
                stickyNoteMetaData.SetTheme(theme);
                stickyNoteManifest[stickyNoteIndex] = stickyNoteMetaData;
                EditorUtility.SetDirty(this);
                return stickyNoteMetaData;
            }
            throw new Exception("No sticky note meta data found with the inputted uid.");
        }
                
        /// <summary>
        /// Updates the lock state of the sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem UpdateStickyNoteIsLocked(string uid, bool isLocked)
        {
            if (HasStickyNoteMetaData(uid))
            {
                var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
                var stickyNoteIndex = Array.IndexOf(stickyNoteManifest, stickyNoteMetaData);
                stickyNoteMetaData.SetIsLocked(isLocked);
                stickyNoteManifest[stickyNoteIndex] = stickyNoteMetaData;
                EditorUtility.SetDirty(this);
                return stickyNoteMetaData;
            }
            throw new Exception("No sticky note meta data found with the inputted uid.");
        }
                
        /// <summary>
        /// Removes the referenced sticky note meta data.
        /// </summary>
        public void RemoveStickyNoteMetaData(string uid)
        {
            if (!HasStickyNoteMetaData(uid))
                throw new Exception($"Failed to remove sticky note with Uid {uid} because it doesn't exist.");
            
            var stickyNoteMetaData = TryGetStickyNoteMetaData(uid);
            ArrayUtility.Remove(ref stickyNoteManifest, stickyNoteMetaData);
            EditorUtility.SetDirty(this);
        }
                
        /// <summary>
        /// Tries to get the meta data of the inputted sticky note.
        /// </summary>
        public JungleStickyNoteManifestItem TryGetStickyNoteMetaData(string uid)
        {
            return Array.Find(stickyNoteManifest, stickyNoteMeta => stickyNoteMeta.Uid == uid);
        }
        
        /// <summary>
        /// Returns true if the sticky note exists.
        /// </summary>
        public bool HasStickyNoteMetaData(string uid)
        {
            return Array.Exists(stickyNoteManifest, stickyNoteMeta => stickyNoteMeta.Uid == uid);
        }

        #endregion
    }
    
    /// <summary>
    /// Contains meta data about a Jungle Node.
    /// </summary>
    [Serializable]
    public struct JungleNodeManifestItem
    {
        /// <summary>
        /// The Uid of the Jungle Node this meta data belongs to.
        /// </summary>
        public string Uid
        {
            get => uid;
            internal set => uid = value;
        }
        [SerializeField] [HideInInspector]
        private string uid;

        /// <summary>
        /// The graph position of the Jungle Node.
        /// </summary>
        public Vector2 GraphPosition
        {
            get => graphPosition;
            internal set => graphPosition = value;
        }
        [SerializeField] [HideInInspector]
        private Vector2 graphPosition;
        
        /// <summary>
        /// The last known type name of the Jungle Node.
        /// </summary>
        public string LastKnownTypeName => lastKnownTypeName;
        [SerializeField] [HideInInspector]
        private string lastKnownTypeName;
        
        /// <summary>
        /// The last known title of the Jungle Node.
        /// </summary>
        public string LastKnownTitle => lastKnownTitle;
        [SerializeField] [HideInInspector]
        private string lastKnownTitle;
        
        public JungleNodeManifestItem(JungleNode jungleNode, Vector2 graphPosition)
        {
            uid = jungleNode.Uid;
            lastKnownTypeName = jungleNode.GetType().AssemblyQualifiedName;
            lastKnownTitle = jungleNode.GetTitle();
            this.graphPosition = graphPosition;
        }
        
        /// <summary>
        /// Updates both the last known type name and title of the inputted Jungle Node.
        /// </summary>
        public void UpdateLastKnownItems(JungleNode jungleNode)
        {
            lastKnownTypeName = jungleNode.GetType().AssemblyQualifiedName;
            lastKnownTitle = jungleNode.GetTitle();
        }
    }
    
    /// <summary>
    /// Contains meta data about a Jungle Sticky Note.
    /// </summary>
    [Serializable]
    public struct JungleStickyNoteManifestItem
    {
        /// <summary>
        /// The Uid of the Jungle Sticky Note this meta data belongs to.
        /// </summary>
        public string Uid => uid;
        [SerializeField] [HideInInspector]
        private string uid;
        internal string GenerateNewUid()
        {
            uid = Guid.NewGuid().ToString();
            return uid;
        }
        
        /// <summary>
        /// The graph position of the Jungle Sticky Note.
        /// </summary>
        public Vector2 GraphPosition => graphPosition;
        [SerializeField] [HideInInspector]
        private Vector2 graphPosition;
        public void SetGraphPosition(Vector2 position)
        {
            graphPosition = position;
        }

        /// <summary>
        /// The graph size of the Jungle Sticky Note.
        /// *Minimum size is 200x200*
        /// </summary>
        public Vector2 GraphSize => graphSize;
        [SerializeField] [HideInInspector]
        private Vector2 graphSize;
        public void SetGraphSize(Vector2 size)
        {
            graphSize = size;
        }
        
        /// <summary>
        /// The content of the Jungle Sticky Note.
        /// </summary>
        public string Content => content;
        [SerializeField] [HideInInspector]
        private string content;
        public void SetContent(string content)
        {
            this.content = content;
        }

        /// <summary>
        /// The theme of the Jungle Sticky Note.
        /// *Can be yellow, green, blue, or pink*
        /// </summary>
        public string Theme => theme;
        [SerializeField] [HideInInspector]
        private string theme;
        public void SetTheme(string theme)
        {
            if (string.IsNullOrEmpty(theme))
                theme = "yellow";
            this.theme = theme;
        }
        
        /// <summary>
        /// If the Jungle Sticky Note is locked or not.
        /// </summary>
        public bool IsLocked => isLocked;
        [SerializeField] [HideInInspector]
        private bool isLocked;
        public void SetIsLocked(bool isLocked)
        {
            this.isLocked = isLocked;
        }
        
        public JungleStickyNoteManifestItem(Vector2 graphPosition, Vector2 graphSize, string content, string theme, bool isLocked)
        {
            uid = Guid.NewGuid().ToString();
            this.graphPosition = graphPosition;
            this.graphSize = graphSize;
            this.content = content;
            this.theme = theme;
            this.isLocked = isLocked;
        }
    }
    
    [CustomEditor(typeof(JungleManifest))]
    internal class JungleManifestEditor : Editor
    {
        public override void OnInspectorGUI() { }
    }
}
#endif

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle
{
    /// <summary>
    /// Base Jungle Node class.
    /// </summary>
    [Serializable] [NodeProperties]
    public abstract class JungleNode : ScriptableObject
    {
        #region Properties

        #region Colors

        /// <summary>
        /// #DC1313
        /// </summary>
        public const string Red    = "#DC1313";
        
        /// <summary>
        /// #FF5B00
        /// </summary>
        public const string Orange = "#FF5B00";
        
        /// <summary>
        /// #F29E06
        /// </summary>
        public const string Yellow = "#F29E06";
        
        /// <summary>
        /// #38CA42
        /// </summary>
        public const string Green  = "#38CA42";
        
        /// <summary>
        /// #15DEAB
        /// </summary>
        public const string Teal   = "#15DEAB";
        
        /// <summary>
        /// #00EAFF
        /// </summary>
        public const string Cyan   = "#00EAFF";
        
        /// <summary>
        /// #0069FF
        /// </summary>
        public const string Blue   = "#0069FF";
        
        /// <summary>
        /// #B300FF
        /// </summary>
        public const string Purple = "#B300FF";
        
        /// <summary>
        /// #FF00EA
        /// </summary>
        public const string Pink   = "#FF00EA";
        
        /// <summary>
        /// #85034C
        /// </summary>
        public const string Violet = "#85034C";
        
        /// <summary>
        /// #FFFFFF
        /// </summary>
        public const string White  = "#FFFFFF";
        
        /// <summary>
        /// #101010
        /// </summary>
        public const string Black  = "#101010";

        #endregion
        
        /// <summary>
        /// Equivalent to new Port.None().
        /// </summary>
        public static readonly Port.None Nothing = new(); 
        
        /// <summary>
        /// Reference to the nodes Jungle Tree.
        /// </summary>
        public JungleTree JungleTree => jungleTree;
        [SerializeField] [HideInInspector]
        private JungleTree jungleTree;
        internal void SetJungleTree(JungleTree jungleTree)
        {
            this.jungleTree = jungleTree;
        }
        
        /// <summary>
        /// List of the Jungle Nodes output ports.
        /// </summary>
        public Port[] OutputPorts => outputPorts;
        [SerializeField] [HideInInspector] 
        private Port[] outputPorts = Array.Empty<Port>();

        /// <summary>
        /// The Jungle Nodes unique id.
        /// </summary>
        public string Uid
        {
            get
            {
                if (string.IsNullOrEmpty(uid))
                    GenerateNewUid();
                return uid;
            }
        }
        [SerializeField] [HideInInspector]
        private string uid;
        internal string GenerateNewUid()
        {
            return uid = Guid.NewGuid().ToString();
        }
        
        /// <summary>
        /// Called when this Jungle Node is validated.
        /// True if issues were detected.
        /// </summary>
        public event Action<bool> OnValidated;
        
        /// <summary>
        /// True if this Jungle Node is currently running.
        /// </summary>
        public bool IsRunning => JungleTree.IsNodeRunning(this);
        
        /// <summary>
        /// Returns this Jungle Nodes title.
        /// </summary>
        public string GetTitle()
        {
            var title = GetProperties().Title;
            if (string.IsNullOrEmpty(title))
            {
                return GetType().Name;
            }
            return title;
        }
        
        /// <summary>
        /// Returns a brief description of this Jungle Nodes function. 
        /// </summary>
        public string GetDescription()
        {
            return GetProperties().Description;
        }
        
        /// <summary>
        /// Returns this Jungle Nodes category.
        /// </summary>
        public string GetCategory()
        {
            return GetProperties().Category;
        }
        
        /// <summary>
        /// Returns this Jungle Nodes accent color.
        /// </summary>
        public Color GetColor()
        {
            return ColorUtility.TryParseHtmlString(GetProperties().Color, out var color) 
                ? color 
                : Color.clear;
        }
        
        /// <summary>
        /// Returns this Jungle Nodes script icon.
        /// *Editor Only*
        /// </summary>
        public Texture GetIcon()
        {
#if UNITY_EDITOR
            return JungleIconCache.instance.TryGetIconFromCache(GetType());
#else
            return Texture2D.whiteTexture;
#endif
        }

        /// <summary>
        /// Returns true if this Jungle Node is declared deprecated.
        /// </summary>
        public bool IsDeprecated()
        {
            return GetProperties().Deprecated;
        }
        
        private NodePropertiesAttribute GetProperties()
        {
            return GetType().GetCustomAttributes
            (
                typeof(NodePropertiesAttribute),
                true
            )[0] as NodePropertiesAttribute;
        }
        
        /// <summary>
        /// Returns info about this Jungle Nodes input port.
        /// </summary>
        public virtual Port.Info GetInputPortInfo()
        {
            return new Port.Info("NaN", typeof(Port.Error));
        }
        
        /// <summary>
        /// Returns info about this Jungle Nodes output ports.
        /// </summary>
        public virtual Port.Info[] GetOutputPortsInfo()
        {
            return new[]
            {
                new Port.Info("NaN", typeof(Port.Error))
            };
        }
        
        #endregion
        
        internal abstract void OnStart_Internal(in object inputValue);
        
        internal abstract void OnStop_Internal();
        
        internal abstract void OnUpdate_Internal();
        
        /// <summary>
        /// Override this to add context in the Jungle Editor.
        /// </summary>
        public virtual string GetDetails()
        {
            return string.Empty;
        }
        
        /// <summary>
        /// Performs a validation pass on this Jungle Node.
        /// </summary>
        /// <returns>All validation issues on this Jungle Node.</returns>
        public string[] Validate()
        {
            var validationIssues = new List<string>(OnValidation_Internal());
            if (IsDeprecated())
            {
                validationIssues.Add("This node is marked as deprecated.");
            }
            OnValidated?.Invoke(validationIssues.Count > 0);
            return validationIssues.ToArray();
        }
        internal abstract string[] OnValidation_Internal();
        private void OnValidate() => Validate();
        
        /// <summary>
        /// Call this method to log an error with special formatting.
        /// </summary>
        public void DebugLogError(string error)
        {
#if UNITY_EDITOR
            Debug.LogFormat
            (
                LogType.Error, LogOption.None, this,
                $"[<b>Jungle</b>] > [<b>{JungleTree.name}</b>] > [<b>{name}</b>] Encountered an error:\n" +
                $"<color=#bf3737>{error}</color>" +
                "\n\n<b>Stack Trace:</b>"
            );
#endif
        }
        
        internal abstract void OnConnection_Internal(Port affectedPort, JungleNode connected);
        
        internal abstract void OnDisconnection_Internal(Port affectedPort, JungleNode disconnected);
        
#if UNITY_EDITOR
        internal bool MakeConnection_Internal(JungleNode nodeToConnect, byte portIndex)
        {
            if (nodeToConnect.JungleTree != JungleTree)
                return false;
            
            RefreshConnections_Internal();
            if (portIndex >= outputPorts.Length)
                return false;
            if (GetOutputPortsInfo()[portIndex].Type == typeof(Port.NA) && 
                nodeToConnect.GetInputPortInfo().Type == typeof(Port.NA))
                return false;
            if (outputPorts[portIndex].Connections.Contains(nodeToConnect))
                return false;
            
            var newOutputPortConnectionsList = new List<JungleNode>(outputPorts[portIndex].Connections)
            {
                nodeToConnect
            };
            outputPorts[portIndex].Connections = newOutputPortConnectionsList.ToArray();
            
            OnConnection_Internal(outputPorts[portIndex], nodeToConnect);
            nodeToConnect.OnConnection_Internal(outputPorts[portIndex], this);
            
            EditorUtility.SetDirty(this);
            return true;
        }
        
        internal bool RemoveConnection_Internal(JungleNode nodeToDisconnect, byte portIndex)
        {
            if (nodeToDisconnect.JungleTree != JungleTree)
                return false;
            
            RefreshConnections_Internal();
            if (portIndex >= outputPorts.Length)
                return false;
            if (!outputPorts[portIndex].Connections.Contains(nodeToDisconnect))
                return false;
            
            var newOutputPortConnectionsList = new List<JungleNode>(outputPorts[portIndex].Connections);
            newOutputPortConnectionsList.Remove(nodeToDisconnect);
            outputPorts[portIndex].Connections = newOutputPortConnectionsList.ToArray();
           
            OnDisconnection_Internal(outputPorts[portIndex], nodeToDisconnect);
            nodeToDisconnect.OnDisconnection_Internal(outputPorts[portIndex], this);
            
            EditorUtility.SetDirty(this);
            return true;
        }
        
        internal void RemoveAllOutputConnections_Internal()
        {
            for (var i = 0; i < outputPorts.Length; i++)
            {
                foreach (var connection in outputPorts[i].Connections)
                {
                    connection.OnDisconnection_Internal(outputPorts[i], this);
                }
                outputPorts[i] = new Port(this, (byte)i, Array.Empty<JungleNode>());
            }
            EditorUtility.SetDirty(this);
        }
        
        internal void RefreshConnections_Internal()
        {
            var outputPortsData = GetOutputPortsInfo();
            if (OutputPorts.Length != outputPortsData.Length)
            {
                if (outputPortsData.Length > OutputPorts.Length)
                {
                    for (var i = OutputPorts.Length; i < outputPortsData.Length; i++)
                    {
                        var newOutputPort = new Port(this, (byte)i, Array.Empty<JungleNode>());
                        outputPorts = OutputPorts.Append(newOutputPort).ToArray();
                    }
                }
                else outputPorts = OutputPorts.Take(outputPortsData.Length).ToArray();
            }
            
            for (int i = 0; i < OutputPorts.Length; i++)
            {
                var port = OutputPorts[i];
                port.Connections = port.Connections.Where(node => node != null).ToArray();
                port.Connections = port.Connections.Where(node => node.JungleTree == JungleTree).ToArray();
                port.Connections = port.Connections.Where(node => node.GetInputPortInfo().Type != port.GetPortOutputType()).ToArray();
            }
        }
#endif
    }
    
    /// <summary>
    /// Jungle Nodes editor properties.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class NodePropertiesAttribute : Attribute
    {
        /// <summary>
        /// This Jungle Nodes display name.
        /// </summary>
        public string Title
        {
            get; 
            set;
        } = string.Empty;

        /// <summary>
        /// A brief description of this Jungle Nodes function. As used as the tooltip.
        /// </summary>
        public string Description
        {
            get; 
            set;
        } = string.Empty;

        /// <summary>
        /// The path to insert this Jungle Node into the Node Browser.
        /// </summary>
        public string Category
        {
            get;
            set;
        } = string.Empty;

        /// <summary>
        /// This Jungle Nodes accent color. *Hex code*
        /// </summary>
        public string Color
        {
            get;
            set;
        } = JungleNode.Blue;
        
        /// <summary>
        /// Declares whether this Jungle Node is deprecated or not.
        /// </summary>
        public bool Deprecated
        {
            get;
            set;
        } = false;
    }
    
    /// <summary>
    /// Jungle Node port class used for storing references to this ports connections.
    /// </summary>
    [Serializable]
    public struct Port
    {
        /// <summary>
        /// The Jungle Node the port belongs to.
        /// </summary>
        public JungleNode JungleNode => jungleNode;
        [SerializeField] [HideInInspector]
        private JungleNode jungleNode;
        
        [SerializeField] [HideInInspector]
        private byte portIndex;
        
        /// <summary>
        /// List of Jungle Nodes this port connects to.
        /// </summary>
        public JungleNode[] Connections
        {
            get => connections;
            internal set => connections = value;
        }
        [SerializeField] [HideInInspector]
        private JungleNode[] connections;
        
        internal Port(JungleNode jungleNode, byte portIndex, JungleNode[] connections)
        {
            this.jungleNode = jungleNode;
            this.portIndex = portIndex;
            this.connections = connections;
        }
        
        /*
        public void CleanUpConnections()
        {
            var port = this;
            var connectionsList = new List<JungleNode>(connections);
            
            connectionsList.RemoveAll(node => node == null);
            connectionsList.RemoveAll(node => node.JungleTree != port.JungleNode.JungleTree);
            connectionsList.RemoveAll(node => node.GetInputPortInfo().Type != port.GetPortOutputType());
            
            connections = connectionsList.ToArray();
        }
        */
        
        internal Type GetPortOutputType()
        {
            return JungleNode.GetOutputPortsInfo()[portIndex].Type;
        }
        
        /// <summary>
        /// Jungle Port call.
        /// </summary>
        public struct Call
        {
            /// <summary>
            /// Index of the port to send the value to.
            /// </summary>
            public byte PortIndex
            {
                get; 
                private set;
            }

            /// <summary>
            /// Value to send out of the requested port.
            /// </summary>
            public object Value
            {
                get;
                private set;
            }
            
            public Call(byte portIndex, object value)
            {
                PortIndex = portIndex;
                Value = value;
            }

            public override string ToString()
            {
                return $"Port Index: <b>{PortIndex}</b>\n" +
                       $"Port Value Type: <b>{Value.GetType().Name}</b>";
            }
        }
        
        /// <summary>
        /// Jungle Port information.
        /// </summary>
        public struct Info
        {
            /// <summary>
            /// The name of this Jungle Port.
            /// </summary>
            public readonly string Name;
            
            /// <summary>
            /// The value type of this Jungle Port.
            /// </summary>
            public readonly Type Type;
        
            public Info(string name, Type type)
            {
                Name = name;
                Type = type;
            }
        }
        
        /// <summary>
        /// Jungle Node port type that denotes a port where no data is accepted or released.
        /// </summary>
        public struct None { }
        
        /// <summary>
        /// Jungle Node port type that denotes a port with an unknown type.
        /// </summary>
        public struct Error { }
        
        /// <summary>
        /// Jungle Node port type that denotes a port with an unassigned type.
        /// </summary>
        public struct NA { }
    }
    
    /// <summary>
    /// Helpful class for calculating value over time.
    /// </summary>
    [Serializable]
    public class OverTimeHelper
    {
        /// <summary>
        /// True if this Over Time Helper is enabled.
        /// Used only for the inspector.
        /// </summary>
        public bool enabled;
        
        /// <summary>
        /// Set true if calculation should use scaled delta time.
        /// </summary>
        [Tooltip("Set true if the motion calculations should use scaled delta time.")]
        public bool scaledTime;
        
        /// <summary>
        /// Time scale rate.
        /// </summary>
        [Tooltip("Time scale rate.")]
        public float rate;
        
        /// <summary>
        /// Motion calculation method.
        /// </summary>
        [Tooltip("Motion calculation method.")]
        public Motion method;
        public enum Motion
        {
            Translate,
            Lerp,
            Slerp,
            SmoothDamp
        }

        /// <summary>
        /// Returns true if the calculation is done.
        /// </summary>
        public bool IsDone => _isDone;
        private bool _isDone;
        
        private readonly float _precision;

        public static OverTimeHelper Default => new(false, true, 1f, Motion.Lerp);
        public OverTimeHelper(bool enabled, bool scaledTime, float rate, Motion method, float precision = 0.01f)
        {
            this.enabled = enabled;
            this.scaledTime = scaledTime;
            this.rate = rate;
            this.method = method;
            _precision = precision;
            _isDone = false;
        }
        
        /// <summary>
        /// Sets a float value over time.
        /// </summary>
        public float SetFloatOverTime(float currentValue, float targetValue)
        {
            var deltaTime = GetDeltaTime();
            var value = method switch
            {
                Motion.Translate => Mathf.MoveTowards(currentValue, targetValue, deltaTime),
                Motion.Lerp => Mathf.Lerp(currentValue, targetValue, deltaTime),
                Motion.Slerp => Mathf.Lerp(currentValue, targetValue, deltaTime),
                Motion.SmoothDamp => Mathf.SmoothDamp(currentValue, targetValue, ref currentValue, deltaTime),
                _ => currentValue
            };
            if (Mathf.Abs(targetValue - currentValue) < _precision)
            {
                return targetValue;
            }
            return value;
        }
        
        /// <summary>
        /// Sets a Vector2 value over time.
        /// </summary>
        public Vector2 SetVector2OverTime(Vector2 currentValue, Vector2 targetValue)
        {
            var deltaTime = GetDeltaTime();
            var value = method switch
            {
                Motion.Translate => Vector2.MoveTowards(currentValue, targetValue, deltaTime),
                Motion.Lerp => Vector2.Lerp(currentValue, targetValue, deltaTime),
                Motion.Slerp => Vector2.Lerp(currentValue, targetValue, deltaTime),
                Motion.SmoothDamp => Vector2.SmoothDamp(currentValue, targetValue, ref currentValue, deltaTime),
                _ => currentValue
            };
            if (Vector2.Distance(currentValue, targetValue) < _precision)
            {
                return targetValue;
            }
            return value;
        }

        /// <summary>
        /// Sets a Vector3 value over time.
        /// </summary>
        public Vector3 SetVector3OverTime(Vector3 currentValue, Vector3 targetValue)
        {
            var deltaTime = GetDeltaTime();
            var value = method switch
            {
                Motion.Translate => Vector3.MoveTowards(currentValue, targetValue, deltaTime),
                Motion.Lerp => Vector3.Lerp(currentValue, targetValue, deltaTime),
                Motion.Slerp => Vector3.Slerp(currentValue, targetValue, deltaTime),
                Motion.SmoothDamp => Vector3.SmoothDamp(currentValue, targetValue, ref currentValue, deltaTime),
                _ => currentValue
            };
            if (Vector3.Distance(currentValue, targetValue) < _precision)
            {
                return targetValue;
            }
            return value;
        }
        
        /// <summary>
        /// Sets a Quaternion value over time.
        /// </summary>
        public Quaternion SetQuaternionOverTime(Quaternion currentValue, Quaternion targetValue)
        {
            var deltaTime = GetDeltaTime();
            var value = method switch
            {
                Motion.Translate => Quaternion.RotateTowards(currentValue, targetValue, deltaTime),
                Motion.Lerp => Quaternion.Lerp(currentValue, targetValue, deltaTime),
                Motion.Slerp => Quaternion.Slerp(currentValue, targetValue, deltaTime),
                Motion.SmoothDamp => Quaternion.RotateTowards(currentValue, targetValue, deltaTime),
                _ => currentValue
            };
            if (Quaternion.Angle(currentValue, targetValue) < _precision)
            {
                return targetValue;
            }
            return value;
        }
        
        /// <summary>
        /// Sets a Color value over time.
        /// </summary>
        public Color SetColorOverTime(Color currentValue, Color targetValue)
        {
            var deltaTime = GetDeltaTime();
            var value = method switch
            {
                Motion.Translate => Color.Lerp(currentValue, targetValue, deltaTime),
                Motion.Lerp => Color.Lerp(currentValue, targetValue, deltaTime),
                Motion.Slerp => Color.Lerp(currentValue, targetValue, deltaTime),
                Motion.SmoothDamp => Color.Lerp(currentValue, targetValue, deltaTime),
                _ => currentValue
            };
            var colorDifference = Mathf.Sqrt(
                Mathf.Pow(targetValue.r - currentValue.r, 2) +
                Mathf.Pow(targetValue.g - currentValue.g, 2) +
                Mathf.Pow(targetValue.b - currentValue.b, 2) +
                Mathf.Pow(targetValue.a - currentValue.a, 2)
            );
            if (colorDifference < _precision)
            {
                return targetValue;
            }
            return value;
        }
        
        private float GetDeltaTime()
        {
            return scaledTime 
                ? Time.deltaTime * rate 
                : Time.unscaledDeltaTime * rate;
        }
    }
    
#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(OverTimeHelper))]
    internal class OverTimeHelperDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);
        
            var enabledProp = property.FindPropertyRelative("enabled");
            var methodProp = property.FindPropertyRelative("method");
            var timeScaleProp = property.FindPropertyRelative("rate");
            var scaledTimeProp = property.FindPropertyRelative("scaledTime");
            
            var enabledRect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
            enabledProp.boolValue = EditorGUI.Toggle(enabledRect, "Over Time", enabledProp.boolValue);
        
            if (enabledProp.boolValue)
            {
                EditorGUI.indentLevel++;

                var methodRect = new Rect(position.x, position.y + EditorGUIUtility.singleLineHeight, position.width, EditorGUIUtility.singleLineHeight);
                EditorGUI.PropertyField(methodRect, methodProp);
            
                var timeScaleRect = new Rect(position.x, position.y + 2 * EditorGUIUtility.singleLineHeight, position.width, EditorGUIUtility.singleLineHeight);
                EditorGUI.PropertyField(timeScaleRect, timeScaleProp);
            
                var scaledTimeRect = new Rect(position.x, position.y + 3 * EditorGUIUtility.singleLineHeight, position.width, EditorGUIUtility.singleLineHeight);
                EditorGUI.PropertyField(scaledTimeRect, scaledTimeProp);

                EditorGUI.indentLevel--;
            }
        
            EditorGUI.EndProperty();
        }
        
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            var enabledProp = property.FindPropertyRelative("enabled");
            if (enabledProp.boolValue)
                return EditorGUIUtility.singleLineHeight * 4;
            return EditorGUIUtility.singleLineHeight;
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle
{
    /// <summary>
    /// System for handling Jungles runtime logic.
    /// </summary>
    [DisallowMultipleComponent] [AddComponentMenu("")]
    internal class JungleRuntime : MonoBehaviour
    {
        internal Action OnBeforeRender;
        internal Action OnUpdate;
        internal Action OnFixedUpdate;
        
        internal static JungleRuntime Singleton
        {
            get;
            private set;
        }
        
        private void Awake()
        {
            if (Singleton != null)
                enabled = false;
            Singleton = this;
        }
        
        private void OnEnable()     => Application.onBeforeRender += BeforeRender;
        
        private void OnDisable()    => Application.onBeforeRender -= BeforeRender;
        
        private void BeforeRender() => OnBeforeRender?.Invoke();
        
        private void Update()       => OnUpdate?.Invoke();
        
        private void FixedUpdate()  => OnFixedUpdate?.Invoke();
    }
    
    internal static class JungleInitialization
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void BeforeSceneLoadCallback()
        {
            var jungleRuntimeGameObject = new GameObject("[Jungle Runtime]");
            jungleRuntimeGameObject.AddComponent<JungleRuntime>();
            UnityEngine.Object.DontDestroyOnLoad(jungleRuntimeGameObject);
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(JungleRuntime))]
    internal class JungleRuntimeEditor : Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using Jungle.Nodes;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle
{
    /// <summary>
    /// Base Jungle Tree class.
    /// </summary>
    [Serializable]
    [CreateAssetMenu(fileName = "My Jungle Tree", menuName = "Jungle Tree", order = 81)]
    [HelpURL("https://junglesequencer.com/docs/jungle-tree")]
    public class JungleTree : ScriptableObject
    {
        #region Properties
        
        /// <summary>
        /// List of all nodes associated with this Jungle Tree.
        /// </summary>
        public JungleNode[] Nodes => nodes;
        [SerializeField] [HideInInspector]
        private JungleNode[] nodes = Array.Empty<JungleNode>();
        
        /// <summary>
        /// Invoked whenever this Jungle Tree is started.
        /// </summary>
        public event Action OnStart;
        
        /// <summary>
        /// Invoked whenever this Jungle Tree is stopped.
        /// </summary>
        public event Action OnStop;
        
        /// <summary>
        /// Invoked whenever this Jungle Tree encounters an error.
        /// </summary>
        public event Action<ErrorFlags> OnError;
        /// <summary>
        /// Jungle Tree error flags.
        /// </summary>
        public enum ErrorFlags
        {
            /// <summary>
            /// This error is thrown when the Jungle Tree is requested to start while the editor is not in play-mode. 
            /// </summary>
            NotInPlayMode,
            /// <summary>
            /// This error is thrown when a request to start the Jungle Tree is made but the tree is already running.
            /// </summary>
            AlreadyRunning,
            /// <summary>
            /// This error is thrown when the Jungle Tree has no nodes to execute.
            /// </summary>
            NoNodes,
            /// <summary>
            /// This error is thrown when Jungle fails to find a Jungle Runtime instance in the scene.
            /// </summary>
            NoRuntimeInstance,
            /// <summary>
            /// This error is thrown when a node declares an exception during runtime.
            /// </summary>
            NodeRuntimeException,
        }
        
        /// <summary>
        /// The current state of the Jungle Tree.
        /// </summary>
        public StateFlag State => _state;
        [NonSerialized]
        private StateFlag _state = StateFlag.Ready;
        /// <summary>
        /// Jungle Tree state flags.
        /// </summary>
        [Flags]
        public enum StateFlag
        {
            /// <summary>
            /// Describes a Jungle Tree that has never been run and is not currently running.
            /// </summary>
            Ready =    0,
            /// <summary>
            /// Describes a Jungle Tree that is currently running.
            /// </summary>
            Running =  1,
            /// <summary>
            /// Describes a Jungle Tree that is not currently running but has run at some point.
            /// </summary>
            Finished = 0
        }
        
        /// <summary>
        /// True if the Jungle Tree is currently running.
        /// </summary>
        public bool IsRunning => (int)State == 1;
        
        /// <summary>
        /// The amount of time in seconds the Jungle Tree has been running.
        /// </summary>
        public float Time => IsRunning
            ? UnityEngine.Time.unscaledTime - _startRunTime 
            : 0f;
        [NonSerialized]
        private float _startRunTime;
        
        /// <summary>
        /// Returns true if the Jungle Tree is currently running the specified Jungle Node.
        /// </summary>
        public bool IsNodeRunning(JungleNode jungleNode)
        {
            return Array.IndexOf(executionBuffer, jungleNode) <= _executeToIndex;
        }
        
        /// <summary>
        /// Returns a reference to the Jungle Node with the specified name.
        /// If multiple Jungle Nodes share the same name, the first one found will be returned.
        /// </summary>
        public JungleNode GetNodeByName(string jungleNodeName)
        {
            return nodes.FirstOrDefault(jungleNode => jungleNode.name == jungleNodeName);
        }
        
        [SerializeField] [HideInInspector]
        private bool invokeOnBeforeRender;
        
        [SerializeField] [HideInInspector]
        private bool invokeOnUpdate = true;
        
        [SerializeField] [HideInInspector]
        private bool invokeOnFixedUpdate;
        
        [SerializeField] [HideInInspector]
        private JungleNode[] executionBuffer = Array.Empty<JungleNode>();
        
        [NonSerialized]
        private int _executeToIndex = -1;
        [NonSerialized]
        private ActionsList _revertActions;
        internal struct ActionsList
        {
            private List<Action> _actions;
            
            internal void AddAction(Action method)
            {
                _actions ??= new List<Action>();
                if (_actions.Contains(method))
                {
                    RemoveAction(method);
                }
                _actions.Add(method);
            }
            
            internal void RemoveAction(Action method)
            {
                _actions ??= new List<Action>();
                if (!_actions.Contains(method))
                {
                    return;
                }
                _actions.Remove(method);
            }
            
            internal void InvokeAll()
            {
                _actions ??= new List<Action>();
                foreach (var method in _actions)
                {
                    method?.Invoke();
                }
            }
        }
        
#if UNITY_EDITOR
        internal bool InvokeOnBeforeRender()
        {
            return invokeOnBeforeRender;
        }
        internal void SetInvokeOnBeforeRender(bool value)
        {
            if (invokeOnBeforeRender != value && IsRunning)
            {
                JungleRuntime.Singleton.OnBeforeRender += UpdateCallback;
            }
            invokeOnBeforeRender = value;
        }
        
        internal bool InvokeOnUpdate()
        {
            return invokeOnUpdate;
        }
        internal void SetInvokeOnUpdate(bool value)
        {
            if (invokeOnUpdate != value && IsRunning)
            {
                JungleRuntime.Singleton.OnUpdate += UpdateCallback;
            }
            invokeOnUpdate = value;
        }
        
        internal bool InvokeOnFixedUpdate()
        {
            return invokeOnFixedUpdate;
        }
        internal void SetInvokeOnFixedUpdate(bool value)
        {
            if (invokeOnFixedUpdate != value && IsRunning)
            {
                JungleRuntime.Singleton.OnFixedUpdate += UpdateCallback;
            }
            invokeOnFixedUpdate = value;
        }
        
        [SerializeField] [HideInInspector]
        internal string description = null;
        
        [SerializeField] [HideInInspector]
        internal string authorName;
        
        [SerializeField] [HideInInspector]
        internal string creationDate;
        
        internal string Uid
        {
            get => uid;
            set => uid = value;
        }
        [SerializeField] [HideInInspector]
        private string uid;
        
        /// <summary>
        /// The Jungle Trees persistent manifest.
        /// *Editor Only*
        /// </summary>
        public JungleManifest Manifest
        {
            get
            {
                if (manifest != null)
                    return manifest;
            
                // Search for asset first:
                var allSubAssets = AssetDatabase.LoadAllAssetsAtPath(AssetDatabase.GetAssetPath(this));
                foreach (var subAsset in allSubAssets)
                {
                    if (subAsset is not JungleManifest jungleManifest)
                        continue;
                    return manifest = jungleManifest;
                }
            
                // Create the manifest!
                manifest = CreateInstance(typeof(JungleManifest)) as JungleManifest;
                if (manifest == null)
                {
                    Debug.LogFormat
                    (
                        LogType.Error, LogOption.NoStacktrace, this,
                        $"[<b>Jungle</b>] > [<b>{name}</b>] Failed to create a new Jungle Manifest."
                    );
                    return null;
                }
                AssetDatabase.AddObjectToAsset(manifest, this);
                AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(this));
            
                manifest.name = "_Manifest";
                manifest.JungleTree = this;
                manifest.hideFlags = HideFlags.NotEditable |
                                     HideFlags.DontUnloadUnusedAsset |
                                     HideFlags.DontSaveInBuild;
            
                return manifest;
            }
        }
        [SerializeField] [HideInInspector]
        private JungleManifest manifest;
        internal void MakeSureManifestIsInitialized()
        {
            // SUPER BRUTE FORCE but works (and that's all that matters)
            var temp = Manifest;
        }
        
        internal void RebuildNodesList()
        {
            var thisAssetPath = AssetDatabase.GetAssetPath(this);
            var jungleNodes = AssetDatabase.LoadAllAssetsAtPath(thisAssetPath).OfType<JungleNode>().ToArray();
            nodes = jungleNodes.Where(jungleNode => jungleNode != null && jungleNode.JungleTree == this).ToArray();
            RebuildExecutionBuffer();
            EditorUtility.SetDirty(this);
        }
#endif
        
        #endregion
        
        /// <summary>
        /// Starts running the Jungle Tree.
        /// </summary>
        public void Start()
        {
            // Must be in play mode in order to start a Jungle Tree
            if (!Application.isPlaying)
            {
                HandleError(ErrorFlags.NotInPlayMode, new JungleException("Jungle Tree must be started in play mode."));
                return;
            }
            // Jungle Tree must not already be running to start
            if (_state == StateFlag.Running)
            {
                HandleError(ErrorFlags.AlreadyRunning, new JungleException("Jungle Tree is already running."));
                return;
            }
            // Jungle Tree must have nodes to start
            if (nodes == null || nodes.Length == 0)
            {
                HandleError(ErrorFlags.NoNodes, new JungleException("Jungle Tree has no nodes to execute."));
                return;
            }
            
            // Jungle Runtime singleton instance must exist to start
            if (JungleRuntime.Singleton == null)
            {
                HandleError(ErrorFlags.NoRuntimeInstance, new JungleException("Jungle Runtime instance could not be found."));
                return;
            }
            
            // Listen to requested update events
            if (invokeOnBeforeRender)
            {
                JungleRuntime.Singleton.OnBeforeRender += UpdateCallback;
            }
            if (invokeOnUpdate)
            {
                JungleRuntime.Singleton.OnUpdate += UpdateCallback;
            }
            if (invokeOnFixedUpdate)
            {
                JungleRuntime.Singleton.OnFixedUpdate += UpdateCallback;
            }
            
            _revertActions = new ActionsList();
            _startRunTime = UnityEngine.Time.unscaledTime;
            _state = StateFlag.Running;
            
            // Start all event nodes in the Jungle Tree
            var eventNodes = nodes.Where(node => node is EventNode);
            foreach (var node in eventNodes)
            {
                StartNode(node, null);
            }
            
#if UNITY_EDITOR
            EditorApplication.playModeStateChanged += PlayModeStateChangedCallback;
#endif
            
            OnStart?.Invoke();
        }
        
        /// <summary>
        /// Stops running the Jungle Tree.
        /// </summary>
        public void Stop()
        {
            while (_executeToIndex != -1)
            {
                StopNode(executionBuffer[_executeToIndex]);
            }
            _state = StateFlag.Finished;
            
#if UNITY_EDITOR
            EditorApplication.playModeStateChanged -= PlayModeStateChangedCallback;
#endif
            
            // Invoke revert methods
            _revertActions.InvokeAll();
            _revertActions = new ActionsList();
            
            if (JungleRuntime.Singleton != null)
            {
                JungleRuntime.Singleton.OnBeforeRender -= UpdateCallback;
                JungleRuntime.Singleton.OnUpdate -= UpdateCallback;
                JungleRuntime.Singleton.OnFixedUpdate -= UpdateCallback;
            }
            
            OnStop?.Invoke();
        }
        
        internal void Call_Internal(JungleNode jungleNode, IEnumerable<Port.Call> portCalls)
        {
            foreach (var call in portCalls ?? Array.Empty<Port.Call>())
            {
                // Verify port index is within range
                if (call.PortIndex >= jungleNode.OutputPorts.Length)
                {
#if UNITY_EDITOR
                    Debug.LogFormat
                    (
                        LogType.Exception, LogOption.NoStacktrace, this,
                        $"[<b>Jungle</b>] > [<b>{name}</b>] > [<b>{jungleNode.name}</b>] " +
                        "Port call index was out of range.\n" +
                        "<b>Click for more information.</b>\n\n" + 
                        
                        "<b>Explanation:</b>\n" +
                        $"Tried to call from a port at index {call.PortIndex} but the highest index is " +
                        $"{jungleNode.OutputPorts.Length - 1}.\n\n" +
                            
                        "<b>Port Call:</b>\n" +
                        $"{call.ToString()}"
                    );
#endif
                    continue;
                }
                
                foreach (var connection in jungleNode.OutputPorts[call.PortIndex].Connections)
                {
                    // Verify port call type matches connection type
                    if (call.Value != null && connection.GetInputPortInfo().Type != call.Value.GetType())
                    {
#if UNITY_EDITOR
                        Debug.LogFormat
                        (
                            LogType.Exception, LogOption.NoStacktrace, this,
                            $"[<b>Jungle</b>] > [<b>{name}</b>] > [<b>{jungleNode.name}</b>] " +
                            "Port call value was of the incorrect type.\n" +
                            "<b>Click for more information.</b>\n\n" + 
                            
                            "<b>Flow:</b>\n" +
                            $"{jungleNode.name} -> {connection.name}\n\n" +
                            
                            "<b>Explanation:</b>\n" +
                            $"\"{jungleNode.name}\" made a port call to \"{connection.name}\". The value was of the " +
                            $"type \"{call.Value.GetType().Name}\" but the connected input port only accepts a value " +
                            $"of type \"{connection.GetInputPortInfo().Type.Name}\".\n\n" +
                            
                            "<b>Port Call:</b>\n" +
                            $"{call.ToString()} <- (Should be \"{connection.GetInputPortInfo().Type.Name}\")"
                        );
#endif
                        continue;
                    }
                    
                    StartNode(connection, call.Value);
                }
            }
        }
        
        internal void CallAndStop_Internal(JungleNode jungleNode, IEnumerable<Port.Call> portCalls)
        {
            Call_Internal(jungleNode, portCalls);
            StopNode(jungleNode);
        }
        
        private void StartNode(JungleNode jungleNode, object inputValue)
        {
            var referenceIndex = Array.IndexOf(executionBuffer, jungleNode);
            if (referenceIndex <= _executeToIndex)
                return;

            for (var i = referenceIndex; i > 0; i--)
                executionBuffer[i] = executionBuffer[i - 1];
            executionBuffer[0] = jungleNode;
            _executeToIndex += 1;
            
            try
            {
                jungleNode.OnStart_Internal(inputValue);
            }
            catch (JungleException e)
            {
                HandleError(ErrorFlags.NodeRuntimeException, e);
                StopNode(jungleNode);
            }
        }
        
        private void StopNode(JungleNode jungleNode)
        {
            var referenceIndex = Array.IndexOf(executionBuffer, jungleNode);
            if (referenceIndex > _executeToIndex)
                return;
        
            for (var i = referenceIndex; i < executionBuffer.Length - 1; i++)
            {
                executionBuffer[i] = executionBuffer[i + 1];
            }
            executionBuffer[^1] = jungleNode;
            _executeToIndex -= 1;
            
            try
            {
                jungleNode.OnStop_Internal();
                if (_executeToIndex == -1)
                    Stop();
            }
            catch (JungleException e)
            {
                HandleError(ErrorFlags.NodeRuntimeException, e);
            }
        }
        
        private void UpdateCallback() => UpdateNodes();
        private void UpdateNodes()
        {
            for (var i = 0; i <= _executeToIndex; i++)
            {
                try
                {
                    executionBuffer[i].OnUpdate_Internal();
                }
                catch (JungleException e)
                {
                    HandleError(ErrorFlags.NodeRuntimeException, e);
                    StopNode(executionBuffer[i]);
                }
            }
        }
        
        /// <summary>
        /// Adds an action to be invoked when the Jungle Tree stops.
        /// </summary>
        public void AddRevertAction(Action action)
        {
            _revertActions.AddAction(action);
        }
        
        /// <summary>
        /// Removes an action from the revert list.
        /// </summary>
        public void RemoveRevertAction(Action action)
        {
            _revertActions.RemoveAction(action);
        }
        
        private void RebuildExecutionBuffer()
        {
            executionBuffer = new JungleNode[Nodes.Length];
            for (var i = 0; i < Nodes.Length; i++)
                executionBuffer[i] = Nodes[i];
        }
        
        private void HandleError(ErrorFlags errorFlag, JungleException e)
        {
#if UNITY_EDITOR
            Debug.LogFormat
            (
                LogType.Exception, LogOption.None, this,
                $"[<b>Jungle</b>] > [<b>{name}</b>] Encountered error: {errorFlag.ToString()}" +
                $"\n<color=#bf3737>{e.Message}</color>" +
                "\n\n<b>Stack Trace:</b>"
            );
#endif
            OnError?.Invoke(errorFlag);
        }
        
#if UNITY_EDITOR
        /// <summary>
        /// Adds a Jungle Node to the Jungle Tree.
        /// </summary>
        public JungleNode AddNode(Type nodeType, Vector2 graphPosition)
        {
            if (nodeType.IsAbstract)
            {
                Debug.LogFormat
                (
                    LogType.Error, 
                    LogOption.NoStacktrace, 
                    this,
                    $"[Jungle Tree] \"{name}\" attempted to add a Jungle Node of type {nodeType.FullName} but " +
                    "failed because the requested Jungle Node class was abstract."
                );
                return null;
            }
            
            var jungleNodeInstance = CreateInstance(nodeType) as JungleNode;
            if (jungleNodeInstance == null)
            {
                Debug.LogFormat
                (
                    LogType.Error, 
                    LogOption.NoStacktrace, 
                    this,
                    $"[Jungle Tree] \"{name}\" attempted to add a Jungle Node of type {nodeType.FullName} but " +
                    $"failed because the type did not inherit from type {typeof(JungleNode).FullName}."
                );
                return null;
            }
            
            jungleNodeInstance.SetJungleTree(this);
            jungleNodeInstance.name = $"{jungleNodeInstance.GetTitle()}";
            jungleNodeInstance.name = GetUniqueName(jungleNodeInstance);
            jungleNodeInstance.GenerateNewUid();
            jungleNodeInstance.RefreshConnections_Internal();
            
            // Undo redo implementation
            var path = AssetDatabase.GetAssetPath(this);
            if (jungleNodeInstance.GetType() != typeof(StartNode))
            {
                Undo.SetCurrentGroupName($"Added {jungleNodeInstance.name} to {name}");
                var undoRedoGroupID = Undo.GetCurrentGroup();
                
                Undo.RecordObject(Manifest, string.Empty);
                Manifest.UpdateNodeMetaData(jungleNodeInstance, graphPosition);
                
                AssetDatabase.AddObjectToAsset(jungleNodeInstance, path);
                Undo.RegisterCreatedObjectUndo(jungleNodeInstance, string.Empty);
                
                Undo.CollapseUndoOperations(undoRedoGroupID);
            }
            // This keeps developers from undoing the creation of the start node
            else
            {
                AssetDatabase.AddObjectToAsset(jungleNodeInstance, path);
                Manifest.UpdateNodeMetaData(jungleNodeInstance, graphPosition);
            }
            
            // Unity editor implementation
            AssetDatabase.ImportAsset(path);
            
            RebuildNodesList();
            return jungleNodeInstance;
        }
        
        /// <summary>
        /// Adds multiple Jungle Nodes to the Jungle Tree.
        /// </summary>
        public JungleNode[] AddNodes(JungleNode[] jungleNodes, Vector2[] graphPositions)
        {
            if (jungleNodes == null || jungleNodes.Length == 0)
                return null;
            
            var jungleNodeInstances = jungleNodes.ToList().ConvertAll(Instantiate);
            if (jungleNodeInstances.Count == 0)
                return null;
            
            // Remove all persisted connections
            foreach (var jungleNodeInstance in jungleNodeInstances)
            {
                var jungleNodeInstancePortList = jungleNodeInstance.OutputPorts.ToList();
                foreach (var port in jungleNodeInstancePortList)
                {
                    foreach (var connection in port.Connections)
                    {
                        jungleNodeInstance.RemoveConnection_Internal
                        (
                            connection,
                            (byte)jungleNodeInstancePortList.IndexOf(port)
                        );
                    }
                }
                
                jungleNodeInstance.SetJungleTree(this);
                jungleNodeInstance.name = GetUniqueName(jungleNodeInstance);
                jungleNodeInstance.GenerateNewUid();
                jungleNodeInstance.RefreshConnections_Internal();
            }
            
            // Undo redo implementation
            var undoRedoGroupName = $"Duplicated {jungleNodes[0].name} to {name}";
            if (jungleNodeInstances.Count > 1)
                undoRedoGroupName = $"Duplicated {jungleNodeInstances.Count} nodes to {name}";
            
            Undo.SetCurrentGroupName(undoRedoGroupName);
            var undoRedoGroupID = Undo.GetCurrentGroup();
            
            Undo.RecordObject(Manifest, string.Empty);
            foreach (var jungleNodeInstance in jungleNodeInstances)
                Manifest.UpdateNodeMetaData(jungleNodeInstance, graphPositions[jungleNodeInstances.IndexOf(jungleNodeInstance)]);
            
            var path = AssetDatabase.GetAssetPath(this);
            foreach (var jungleNodeInstance in jungleNodeInstances)
            {
                AssetDatabase.AddObjectToAsset(jungleNodeInstance, path);
                Undo.RegisterCreatedObjectUndo(jungleNodeInstance, string.Empty);
            }
            
            Undo.CollapseUndoOperations(undoRedoGroupID);
            
            // Unity editor implementation
            AssetDatabase.ImportAsset(path);
            
            RebuildNodesList();
            return jungleNodeInstances.ToArray();
        }
        
        /// <summary>
        /// Removes a node from the Jungle Tree.
        /// </summary>
        public void RemoveNode(JungleNode jungleNode)
        {
            RemoveNodes(new[] { jungleNode });
        }
        
        /// <summary>
        /// Removes these nodes from the Jungle Tree.
        /// </summary>
        public void RemoveNodes(JungleNode[] jungleNodes)
        {
            if (jungleNodes == null || jungleNodes.Length == 0)
                return;
            
            var query = jungleNodes.ToList();
            query.RemoveAll(node => node.GetType() == typeof(StartNode));
            var removedBecauseJungleTreeMismatch = query.RemoveAll(node => node.JungleTree != this);
#if UNITY_EDITOR
            if (removedBecauseJungleTreeMismatch > 0)
            {
                Debug.LogFormat
                (
                    LogType.Error, 
                    LogOption.NoStacktrace, 
                    this,
                    $"[Jungle Tree] \"{name}\" attempted to remove {removedBecauseJungleTreeMismatch} Jungle " +
                    "Nodes but failed because the Jungle Nodes were not associated with this Jungle Tree."
                );
            }
#endif
            
            // Undo redo implementation
            var undoRedoGroupName = $"Removed {jungleNodes[0].name} from {name}";
            if (query.Count > 1)
                undoRedoGroupName = $"Removed {query.Count} nodes from {name}";
            
            Undo.SetCurrentGroupName(undoRedoGroupName);
            var undoRedoGroupID = Undo.GetCurrentGroup();
            
            Undo.RecordObject(Manifest, string.Empty);
            foreach (var jungleNode in jungleNodes)
                Manifest.RemoveNodeMetaData(jungleNode);
            
            foreach (var jungleNode in jungleNodes)
                Undo.DestroyObjectImmediate(jungleNode);
            
            Undo.CollapseUndoOperations(undoRedoGroupID);
            
            // Unity editor implementation
            AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(this));
            
            RebuildNodesList();
        }
        
        /// <summary>
        /// Connects two Jungle Nodes together.
        /// </summary>
        /// <param name="nodeA">The parent Jungle Node to connect from.</param>
        /// <param name="nodeB">The child Jungle Node to connect to.</param>
        /// <param name="portIndex">Node B's output port index to connect to.</param>
        public bool ConnectNodes(JungleNode nodeA, JungleNode nodeB, byte portIndex)
        {
            Undo.RecordObject(nodeA, $"Connected {nodeA.name} to {nodeB.name}");
            return nodeA.MakeConnection_Internal(nodeB, portIndex);
        }
        
        /// <summary>
        /// Disconnects two Jungle Nodes from each other.
        /// </summary>
        /// <param name="nodeA">The parent Jungle Node to disconnect from.</param>
        /// <param name="nodeB">The child Jungle Node to disconnect from.</param>
        /// <param name="portIndex">Node B's output port index to disconnect from.</param>
        public bool DisconnectNodes(JungleNode nodeA, JungleNode nodeB, byte portIndex)
        {
            Undo.RecordObject(nodeA, $"Disconnected {nodeA.name} from {nodeB.name}");
            return nodeA.RemoveConnection_Internal(nodeB, portIndex);
        }
        
        private void PlayModeStateChangedCallback(PlayModeStateChange state)
        {
            if (state != PlayModeStateChange.ExitingPlayMode)
                return;
            EditorApplication.playModeStateChanged -= PlayModeStateChangedCallback;
            Stop();
        }
#endif
        
        private string GetUniqueName(JungleNode jungleNode)
        {
            var baseName = jungleNode.name;
            baseName = baseName.Trim().Split('(')[0].Replace(" ", string.Empty);
            
            // Check if the baseName ends with "_number" and remove that part
            var regex = new Regex(@"_(\d+)$");
            var match = regex.Match(baseName);
            if (match.Success)
                baseName = regex.Replace(baseName, "");
            
            var numberOfInstancesWithName = Nodes.Count(node =>
                node.name.StartsWith(baseName) &&
                (node.name == baseName || node.name.StartsWith(baseName + "_")));
            
            return numberOfInstancesWithName == 0 
                ? baseName 
                : $"{baseName}_{numberOfInstancesWithName}";
        }
    }
    
    /// <summary>
    /// Jungle exception container.
    /// </summary>
    public class JungleException : Exception
    {
        public JungleException(string message) : base(message) { }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(JungleTree))]
    internal class JungleTreeEditor : Editor
    { 
        private const double REPAINT_FREQUENCY_SECONDS = 0.1f;
        
        internal static GUIContent PlayIcon => _playIcon ??= EditorGUIUtility.IconContent
        (
            EditorGUIUtility.isProSkin
                ? "d_PlayButton@2x"
                : "PlayButton@2x"
        );
        private static GUIContent _playIcon;
        
        internal static GUIContent StopIcon => _stopIcon ??= EditorGUIUtility.IconContent
        (
            EditorGUIUtility.isProSkin
                ? "d_PreMatQuad@2x"
                : "PreMatQuad@2x"
        );
        private static GUIContent _stopIcon;
        
        private double _lastRepaintTime;
        private JungleTree _jungleTree;
        
        private void OnEnable()
        {
            _jungleTree = target as JungleTree;
            
            _lastRepaintTime = EditorApplication.timeSinceStartup;
            EditorApplication.update += UpdateCallback;
        }
        
        private void OnDisable()
        {
            EditorApplication.update -= UpdateCallback;
        }
        
        private void UpdateCallback()
        {
            if (EditorApplication.timeSinceStartup - _lastRepaintTime < REPAINT_FREQUENCY_SECONDS)
                return;
            
            _lastRepaintTime = EditorApplication.timeSinceStartup;
            Repaint();
        }
        
        public override void OnInspectorGUI()
        {
            DrawDescription();
            DrawDivider();
            DrawControlBox();
        }
        
        private void DrawDescription()
        {
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Details", EditorStyles.boldLabel);
                var description = GUILayout.TextArea(_jungleTree.description ?? "\n", 500);
                if (!description.EndsWith('\n'))
                    description += '\n';
                if (_jungleTree.description != null && _jungleTree.description != description)
                {
                    _jungleTree.description = description;
                    EditorUtility.SetDirty(_jungleTree);
                }
                GUILayout.Space(5f);
                GUI.enabled = false;
                if (string.IsNullOrEmpty(_jungleTree.authorName))
                {
                    var signature = EditorPrefs.GetString("Jungle.Signature", string.Empty);
                    if (string.IsNullOrEmpty(signature))
                        signature = "Unknown";
                    _jungleTree.authorName = signature;
                }
                GUILayout.Label($"Created By: {_jungleTree.authorName}");
                
                if (string.IsNullOrEmpty(_jungleTree.creationDate))
                {
                    var now = DateTime.Now;
                    _jungleTree.creationDate = $"{now.ToShortDateString()} at {now.ToShortTimeString()}";
                }
                GUILayout.Label($"Created On: {_jungleTree.creationDate}");
                GUI.enabled = true;
            GUILayout.EndVertical();
        }
        
        private void DrawDivider()
        {
            GUILayout.Space(2f);
            EditorGUI.DrawRect(EditorGUILayout.GetControlRect(false, 1), EditorGUIUtility.isProSkin 
                ? new Color(0.7f, 0.7f, 0.7f, 0.5f) 
                : new Color(0.3f, 0.3f, 0.3f, 0.5f));
            GUILayout.Space(2f);
        }
        
        private void DrawControlBox()
        {
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.Label("Update Frequency", EditorStyles.boldLabel);
                GUILayout.BeginHorizontal();
                    var beforeRender = GUILayout.Toggle(_jungleTree.InvokeOnBeforeRender(), "Before Render");
                    if (_jungleTree.InvokeOnBeforeRender() != beforeRender)
                    {
                        if (!(!beforeRender && !_jungleTree.InvokeOnUpdate() && !_jungleTree.InvokeOnFixedUpdate()))
                        {
                            _jungleTree.SetInvokeOnBeforeRender(beforeRender);
                            EditorUtility.SetDirty(_jungleTree);
                        }
                    }
                    var update = GUILayout.Toggle(_jungleTree.InvokeOnUpdate(), "Update");
                    if (_jungleTree.InvokeOnUpdate() != update)
                    {
                        if (!(!beforeRender && !update && !_jungleTree.InvokeOnFixedUpdate()))
                        {
                            _jungleTree.SetInvokeOnUpdate(update);
                            EditorUtility.SetDirty(_jungleTree);
                        }
                    }
                    var fixedUpdate = GUILayout.Toggle(_jungleTree.InvokeOnFixedUpdate(), "Fixed Update");
                    if (_jungleTree.InvokeOnFixedUpdate() != fixedUpdate)
                    {
                        if (!(!beforeRender && !update && !fixedUpdate))
                        {
                            _jungleTree.SetInvokeOnFixedUpdate(fixedUpdate);
                            EditorUtility.SetDirty(_jungleTree);
                        }
                    }
                GUILayout.EndHorizontal();
            GUILayout.EndVertical();
            
            GUILayout.BeginVertical(EditorStyles.helpBox);
                GUI.enabled = Application.isPlaying;
                GUILayout.BeginHorizontal();
                    var width = GUILayout.Width(65f);
                    var height = GUILayout.ExpandHeight(true);
                    if (!_jungleTree.IsRunning && GUILayout.Button(PlayIcon, width, height))
                    {
                        _jungleTree.Start();
                    }
                    else if (_jungleTree.IsRunning && GUILayout.Button(StopIcon, width, height))
                    {
                        _jungleTree.Stop();
                    }
                    GUILayout.BeginVertical();
                        GUILayout.Label
                        (
                            $"{(_jungleTree.IsRunning ? "Playing" : "Ready")}",
                            EditorStyles.wordWrappedLabel
                        );
                        var elapsedTime = Math.Round(_jungleTree.Time, 1).ToString(CultureInfo.InvariantCulture);
                        if (!elapsedTime.Contains('.')) elapsedTime += ".0";
                        GUILayout.Label
                        (
                            $"{elapsedTime} seconds",
                            EditorStyles.wordWrappedLabel
                        );
                    GUILayout.EndVertical();
                GUILayout.EndHorizontal();
            GUILayout.EndVertical();
        }
    }
    
    [CustomPropertyDrawer(typeof(JungleTree))]
    internal class JungleTreeDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect rect, SerializedProperty property, GUIContent label)
        {
            rect = new Rect
            (
                rect.position,
                new Vector2
                (
                    rect.width,
                    EditorGUIUtility.singleLineHeight * 2f + 9f
                )
            );
            EditorGUI.BeginProperty(rect, label, property);
            
            // Help box is used as the background
            EditorGUI.HelpBox
            (
                rect,
                string.Empty,
                MessageType.None
            );
            
            var labelRect = new Rect
            (
                rect.x + 5,
                rect.y + 2,
                rect.width,
                EditorGUIUtility.singleLineHeight
            );
            EditorGUI.LabelField(labelRect, label, EditorStyles.boldLabel);
            
            var fieldRect = new Rect
            (
                rect.x + 5,
                labelRect.yMax + 2,
                rect.width - 40,
                EditorGUIUtility.singleLineHeight
            );
            EditorGUI.PropertyField(fieldRect, property, GUIContent.none);
            
            var buttonRect = new Rect
            (
                fieldRect.xMax + 3,
                labelRect.yMax + 1,
                EditorGUIUtility.singleLineHeight + 10,
                EditorGUIUtility.singleLineHeight + 2
            );
            var jungleTree =  property.objectReferenceValue as JungleTree;
            var playIcon = new GUIContent(JungleTreeEditor.PlayIcon);
            var stopIcon = new GUIContent(JungleTreeEditor.StopIcon);
            if (jungleTree != null)
            {
                GUI.enabled = Application.isPlaying;
                if (!jungleTree.IsRunning && GUI.Button(buttonRect, playIcon))
                {
                    jungleTree.Start();
                }
                else if (jungleTree.IsRunning && GUI.Button(buttonRect, stopIcon))
                {
                    jungleTree.Stop();
                }
            }
            else
            {
                GUI.enabled = false;
                GUI.Button(buttonRect, playIcon);
            }
            
            GUI.enabled = true;
            EditorGUI.EndProperty();
        }
        
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return EditorGUIUtility.singleLineHeight * 2f + 9f;
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Get Animator",
        Description = "Gets the Animator on the inputted Game Object.",
        Category = "Animation",
        Color = Purple
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(Animator)
    )]
    public class GetAnimatorNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject inputValue)
        {
            var gameObject = inputValue as UnityEngine.GameObject;
            if (gameObject == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to get Animator because the inputted Game Object was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                var animator = gameObject.GetComponent<Animator>();
                CallAndStop(new []
                {
                    new Port.Call(0, animator)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(GetAnimatorNode))]
    public class GetAnimatorNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            //base.OnInspectorGUI();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Play Animation",
        Description = "Plays an animation on the inputted Animator.",
        Category = "Animation",
        Color = Purple
    )]
    [IONode(
        InputPortName = "Play",
        OutputPortName = "",
        OutputPortType = typeof(Animator)
    )]
    public class PlayAnimationNode : IONode<Animator>
    {
        #region Variables
        
        [SerializeField] [Tooltip("The name of the animation state to play.")]
        private string stateName = "MyAnimation";
        
        [SerializeField] [Tooltip("The layer to play the animation on.")]
        private int layer = -1;
        
        [SerializeField] [Range(0f, 1f)] [Tooltip("The normalized time to play the animation from.")]
        private float normalizedTime;
        
        #endregion
        
        protected override void OnStart(in Animator inputValue)
        {
            var animator = inputValue as Animator;
            if (animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to play animation because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                animator.enabled = true;
                animator.Play(stateName, layer, normalizedTime);
                CallAndStop(new []
                {
                    new Port.Call(0, animator)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
        
        public override string GetDetails()
        {
            var details = $"Play <b>{stateName}</b>";
            
            if (normalizedTime == 0f)
                details += " from <b>the beginning</b>";
            else
                details += $" from <b>{normalizedTime * 100f}%</b>";
            
            if (layer != -1)
                details += $" on layer <b>{layer}</b>";
            
            return details;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(PlayAnimationNode))]
    public class PlayAnimationNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _stateName;
        private SerializedProperty _layer;
        private SerializedProperty _normalizedTime;
        
        private void OnEnable()
        {
            _stateName = serializedObject.FindProperty("stateName");
            _layer = serializedObject.FindProperty("layer");
            _normalizedTime = serializedObject.FindProperty("normalizedTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_stateName);
            EditorGUILayout.PropertyField(_layer);
            EditorGUILayout.PropertyField(_normalizedTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Set Boolean",
        Description = "Sets the bool on the inputted Animator.",
        Category = "Animation",
        Color = Violet
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(Animator)
    )]
    public class SetBooleanNode : IONode<Animator>
    {
        #region Variables

        [SerializeField] [Tooltip("The name of the boolean to set.")]
        private string parameterName = "MyBool";
        
        [SerializeField] [Tooltip("The value to set the boolean to.")]
        private bool value = true;
        
        #endregion
        
        protected override void OnStart(in Animator inputValue)
        {
            var animator = inputValue as Animator;
            if (animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to set boolean because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                animator.SetBool(parameterName, value);
                CallAndStop(new []
                {
                    new Port.Call(0, animator)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            
        }
        
        public override string GetDetails()
        {
            return $"Set <b>{parameterName}</b> to <b>{value.ToString()}</b>";
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(SetBooleanNode))]
    public class SetBooleanNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty parameterName;
        private SerializedProperty value;

        private void OnEnable()
        {
            parameterName = serializedObject.FindProperty("parameterName");
            value = serializedObject.FindProperty("value");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(parameterName);
            EditorGUILayout.PropertyField(value);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using System.Globalization;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Set Float",
        Description = "Sets the float on the inputted Animator.",
        Category = "Animation",
        Color = Violet
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(Animator)
    )]
    public class SetFloatNode : IONode<Animator>
    {
        #region Variables

        [SerializeField] [Tooltip("The name of the float to set.")]
        private string parameterName = "MyFloat";
        
        [SerializeField] [Tooltip("The value to set the float to.")]
        private float value = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Animator _animator;

        #endregion
        
        protected override void OnStart(in Animator inputValue)
        {
            _animator = inputValue as Animator;
            if (_animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to set float because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                var currentValue = _animator.GetFloat(parameterName);
                var newValue = overTime.SetFloatOverTime(currentValue, value);
                _animator.SetFloat(parameterName, overTime.SetFloatOverTime(currentValue, value));
                if (currentValue == newValue)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _animator)
                    });
                }
            }
            else
            {
                _animator.SetFloat(parameterName, value);
                CallAndStop(new []
                {
                    new Port.Call(0, _animator)
                });
            }
        }
        
        public override string GetDetails()
        {
            return $"Set <b>{parameterName}</b> to <b>{value.ToString(CultureInfo.CurrentCulture)}</b>";
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(SetFloatNode))]
    public class SetFloatNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty parameterName;
        private SerializedProperty value;
        private SerializedProperty overTime;
        
        private void OnEnable()
        {
            parameterName = serializedObject.FindProperty("parameterName");
            value = serializedObject.FindProperty("value");
            overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(parameterName);
            EditorGUILayout.PropertyField(value);
            EditorGUILayout.PropertyField(overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Set Integer",
        Description = "Sets the integer on the inputted Animator.",
        Category = "Animation",
        Color = Violet
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(Animator)
    )]
    public class SetIntegerNode : IONode<Animator>
    {
        #region Variables

        [SerializeField] [Tooltip("The name of the integer to set.")]
        private string parameterName = "MyInteger";
        
        [SerializeField] [Tooltip("The value to set the integer to.")]
        private int value = 1;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Animator _animator;

        #endregion
        
        protected override void OnStart(in Animator inputValue)
        {
            _animator = inputValue as Animator;
            if (_animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to set integer because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                var currentValue = _animator.GetInteger(parameterName);
                var newValue = (int)overTime.SetFloatOverTime(currentValue, value);
                _animator.SetInteger(parameterName, newValue);
                if (currentValue == newValue)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _animator)
                    });
                }
            }
            else
            {
                _animator.SetInteger(parameterName, value);
                CallAndStop(new []
                {
                    new Port.Call(0, _animator)
                });
            }
        }

        public override string GetDetails()
        {
            return $"Set <b>{parameterName}</b> to <b>{value.ToString()}</b>";
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetIntegerNode))]
    public class SetIntegerNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty parameterName;
        private SerializedProperty value;
        private SerializedProperty overTime;
        
        private void OnEnable()
        {
            parameterName = serializedObject.FindProperty("parameterName");
            value = serializedObject.FindProperty("value");
            overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(parameterName);
            EditorGUILayout.PropertyField(value);
            EditorGUILayout.PropertyField(overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Set Playback Speed",
        Description = "Sets the playback speed of the inputted Animator.",
        Category = "Animation",
        Color = Purple
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Animator)
    )]
    public class SetPlaybackSpeedNode : IONode<Animator>
    {
        #region Variables
        
        [SerializeField] [Tooltip("The playback speed to set.")]
        private float speed = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Animator _animator;

        #endregion
        
        protected override void OnStart(in Animator inputValue)
        {
            _animator = inputValue as Animator;
            if (_animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to set playback speed because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _animator.speed = overTime.SetFloatOverTime(_animator.speed, speed);
                if (_animator.speed == speed)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _animator)
                    });
                }
            }
            else
            {
                _animator.speed = speed;
                CallAndStop(new []
                {
                    new Port.Call(0, _animator)
                });
            }
        }
        
        public override string GetDetails()
        {
            return $"Set playback speed to <b>{speed}</b>";
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetPlaybackSpeedNode))]
    public class SetPlaybackSpeedNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty speed;
        private SerializedProperty overTime;
        
        private void OnEnable()
        {
            speed = serializedObject.FindProperty("speed");
            overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(speed);
            EditorGUILayout.PropertyField(overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Animation
{
    [NodeProperties(
        Title = "Stop Animator",
        Description = "Stops the inputted Animator.",
        Category = "Animation",
        Color = Purple
    )]
    [IONode(
        InputPortName = "Stop",
        OutputPortName = "",
        OutputPortType = typeof(Animator)
    )]
    public class StopAnimatorNode : IONode<Animator>
    {
        protected override void OnStart(in Animator inputValue)
        {
            var animator = inputValue as Animator;
            if (animator == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to stop Animator because the inputted Animator was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                animator.enabled = false;
                CallAndStop(new []
                {
                    new Port.Call(0, animator)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(StopAnimatorNode))]
    public class StopAnimatorNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            //base.OnInspectorGUI();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Application
{
    [NodeProperties(
        Title = "Open URL",
        Description = "Opens a URL in a web browser.",
        Category = "Application", 
        Color = Violet
    )]
    [GenericNode(
        InputPortName = "Open",
        OutputPortName = ""
    )]
    internal class OpenURLNode : GenericNode
    {
        [SerializeField] [TextArea(1, 2)] [Tooltip("The URL to open in a web browser.")]
        private string urlToOpen = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";

        protected override void OnStart()
        {
            if (!string.IsNullOrEmpty(urlToOpen))
                UnityEngine.Application.OpenURL(urlToOpen);
            CallAndStop();
        }

        protected override void OnUpdate() { }
        
        protected override string[] OnValidation()
        {
            if (string.IsNullOrEmpty(urlToOpen))
                return new[] { "URL to open is empty." };
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(OpenURLNode))]
    internal class OpenURLNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _urlToOpen;
        
        private void OnEnable()
        {
            _urlToOpen = serializedObject.FindProperty("urlToOpen");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_urlToOpen, new GUIContent("URL To Open"));
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Application
{
    [NodeProperties(
        Title = "Quit Application",
        Description = "Quits the application.",
        Category = "Application", 
        Color = Red
    )]
    [GenericNode(
        InputPortName = "Quit",
        OutputPortName = ""
    )]
    public class QuitApplicationNode : GenericNode
    {
        protected override void OnStart()
        {
            if (!UnityEngine.Application.isEditor)
            {
                UnityEngine.Application.Quit();
            }
            else
            {
#if UNITY_EDITOR
                EditorApplication.ExitPlaymode();
#endif
            }
            CallAndStop();
        }

        protected override void OnUpdate()
        {
            
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(QuitApplicationNode))]
    public class QuitApplicationNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            
        }
    }
#endif
}
﻿using System;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Get Audio Source",
        Description = "Gets the Audio Source of the inputted Game Object.",
        Category = "Audio",
        Color = Yellow
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.AudioSource)
    )]
    public class GetAudioSourceNode : IONode<UnityEngine.GameObject>
    {
        #region Variables
        
        [NonSerialized]
        private UnityEngine.AudioSource _audioSource;

        #endregion
        
        protected override void OnStart(in UnityEngine.GameObject inputValue)
        {
            var gameObject = inputValue as UnityEngine.GameObject;
            if (gameObject == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                _audioSource = gameObject.GetComponent<UnityEngine.AudioSource>();
                CallAndStop(new []
                {
                    new Port.Call(0, _audioSource)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            
        }
    }
}

﻿namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Pause",
        Description = "Pauses the inputted Audio Source.",
        Category = "Audio",
        Color = Red
    )]
    [IONode(
        InputPortName = "Pause",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.AudioSource)
    )]
    public class PauseAudioSourceNode : IONode<UnityEngine.AudioSource>
    {
        protected override void OnStart(in UnityEngine.AudioSource inputValue)
        {
            var audioSource = inputValue as UnityEngine.AudioSource;
            if (audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                audioSource.Pause();
                CallAndStop(new []
                {
                    new Port.Call(0, audioSource)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Play",
        Description = "Plays the inputted Audio Source.",
        Category = "Audio",
        Color = Yellow
    )]
    [BranchNode(
        InputPortName = "Play",
        OutputPortNames = new []{ "Start", "End" },
        OutputPortTypes = new []{ typeof(AudioSource), typeof(AudioSource) }
    )]
    public class PlayAudioSourceNode : BranchNode<AudioSource>
    {
        #region Variables

        [NonSerialized]
        private AudioSource _audioSource;

        #endregion
        
        protected override void OnStart(in AudioSource inputValue)
        {
            _audioSource = inputValue as AudioSource;
            if (_audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null),
                    new Port.Call(1, null)
                });
            }
            else
            {
                _audioSource.Play();
                Call(new []
                {
                    new Port.Call(0, _audioSource)
                });
            }
        }

        protected override void OnUpdate()
        {
            if (_audioSource.isPlaying) 
                return;
            
            CallAndStop(new []
            {
                new Port.Call(1, _audioSource)
            });
        }
    }
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Play Clip At Point",
        Description = "Plays an audio clip at a given point in the scene.",
        Category = "Audio",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Play",
        OutputPortName = "Done"
    )]
    internal class PlayClipAtPointNode : GenericNode
    {
        [SerializeField]
        private AudioClip clip;
        
        [SerializeField] [Range(0f, 1f)]
        private float volume = 1f;
        
        [SerializeField] [Tooltip("The position in world space where the sound will be played.")]
        private Vector3 point;
        
        protected override void OnStart()
        {
            AudioSource.PlayClipAtPoint(clip, point, volume);
            CallAndStop();
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(PlayClipAtPointNode))]
    internal class PlayClipAtPointNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _clip;
        private SerializedProperty _point;
        private SerializedProperty _volume;
        
        private void OnEnable()
        {
            _clip = serializedObject.FindProperty("clip");
            _point = serializedObject.FindProperty("point");
            _volume = serializedObject.FindProperty("volume");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_clip);
            EditorGUILayout.PropertyField(_volume);
            EditorGUILayout.PropertyField(_point);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Play One Shot",
        Description = "Plays an audio clip on the inputted Audio Source.",
        Category = "Audio",
        Color = Yellow
    )]
    [IONode(
        InputPortName = "Play",
        OutputPortName = "",
        OutputPortType = typeof(AudioSource)
    )]
    public class PlayOneShotNode : IONode<AudioSource>
    {
        #region Variables

        [SerializeField]
        private AudioClip audioClip;
        
        [SerializeField]
        private float volumeScale = 1f;
        
        #endregion
        
        protected override void OnStart(in AudioSource inputValue)
        {
            var audioSource = inputValue as AudioSource;
            if (audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                audioSource.PlayOneShot(audioClip, volumeScale);
                CallAndStop(new []
                {
                    new Port.Call(0, audioSource)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using UnityEngine;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Set Audio Clip",
        Description = "Sets the audio clip of the inputted Audio Source.",
        Category = "Audio",
        Color = Orange
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(AudioSource)
    )]
    public class SetAudioClip : IONode<AudioSource>
    {
        #region Variables

        [SerializeField]
        private AudioClip audioClip;
        
        #endregion
        
        protected override void OnStart(in AudioSource inputValue)
        {
            var audioSource = inputValue as AudioSource;
            if (audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                audioSource.clip = audioClip;
                CallAndStop(new []
                {
                    new Port.Call(0, audioSource)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Set Pitch",
        Description = "Sets the pitch of the inputted Audio Source.",
        Category = "Audio",
        Color = Orange
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(AudioSource)
    )]
    public class SetPitchNode : IONode<AudioSource>
    {
        #region Variables

        [SerializeField] [Range(-3f, 3f)]
        private float pitch = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;

        [NonSerialized]
        private AudioSource _audioSource;
        
        #endregion
        
        protected override void OnStart(in AudioSource inputValue)
        {
            _audioSource = inputValue as AudioSource;
            if (_audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }

        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _audioSource.pitch = overTime.SetFloatOverTime(_audioSource.pitch, pitch);
                if (_audioSource.pitch == pitch)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _audioSource)
                    });
                }
            }
            else
            {
                _audioSource.pitch = pitch;
                CallAndStop(new []
                {
                    new Port.Call(0, _audioSource)
                });
            }
        }
    }
}
﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Set Volume",
        Description = "Sets the volume of the inputted Audio Source.",
        Category = "Audio",
        Color = Orange
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(AudioSource)
    )]
    public class SetVolumeNode : IONode<AudioSource>
    {
        #region Variables

        [SerializeField] [Range(0f, 1f)]
        private float volume = 1f;

        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private AudioSource _audioSource;
        
        #endregion
        
        protected override void OnStart(in AudioSource inputValue)
        {
            _audioSource = inputValue as AudioSource;
            if (_audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _audioSource.volume = overTime.SetFloatOverTime(_audioSource.volume, volume);
                if (_audioSource.volume == volume)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _audioSource)
                    });
                }
            }
            else
            {
                _audioSource.volume = volume;
                CallAndStop(new []
                {
                    new Port.Call(0, _audioSource)
                });
            }
        }
    }
}

﻿namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Stop",
        Description = "Stops the inputted Audio Source.",
        Category = "Audio",
        Color = Red
    )]
    [IONode(
        InputPortName = "Stop",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.AudioSource)
    )]
    public class StopAudioSourceNode : IONode<UnityEngine.AudioSource>
    {
        protected override void OnStart(in UnityEngine.AudioSource inputValue)
        {
            var audioSource = inputValue as UnityEngine.AudioSource;
            if (audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                audioSource.Stop();
                CallAndStop(new []
                {
                    new Port.Call(0, audioSource)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}

﻿namespace Jungle.Nodes.Audio
{
    [NodeProperties(
        Title = "Un-Pause",
        Description = "Un-Pauses the inputted Audio Source.",
        Category = "Audio",
        Color = Yellow
    )]
    [IONode(
        InputPortName = "Un-Pause",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.AudioSource)
    )]
    public class UnPauseAudioSourceNode : IONode<UnityEngine.AudioSource>
    {
        protected override void OnStart(in UnityEngine.AudioSource inputValue)
        {
            var audioSource = inputValue as UnityEngine.AudioSource;
            if (audioSource == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                audioSource.UnPause();
                CallAndStop(new []
                {
                    new Port.Call(0, audioSource)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}
﻿namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Get Camera",
        Description = "Gets a reference to the inputted GameObject's Camera component.",
        Category = "Camera",
        Color = Green
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class GetCameraNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject == null)
                throw new JungleException("Inputted GameObject is null.");
            
            if (!gameObject.TryGetComponent<UnityEngine.Camera>(out var camera))
                throw new JungleException("Inputted GameObject does not have a Camera component.");
            
            CallAndStop(camera);
        }
        
        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(GetCameraNode))]
    internal class GetCameraNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}
namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Get Main Camera",
        Description = "Gets a reference to the main camera in the scene.",
        Category = "Camera",
        Color = Green
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class GetMainCameraNode : IONode<Port.None>
    {
        protected override void OnStart(in Port.None _)
        {
            var camera = UnityEngine.Camera.main;
            
            if (camera == null)
                throw new JungleException("There is no main camera in the scene.");
            
            CallAndStop(camera);
        }
        
        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(GetMainCameraNode))]
    internal class GetMainCameraNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Render Camera",
        Description = "Renders the inputted Camera manually.",
        Category = "Camera",
        Color = Green
    )]
    [IONode(
        InputPortName = "Render",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class RenderCameraNode : IONode<UnityEngine.Camera>
    {
        protected override void OnStart(in UnityEngine.Camera camera)
        {
            if (camera == null)
                throw new JungleException("Inputted camera is null.");
            
            camera.Render();
            CallAndStop(camera);
        }

        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(RenderCameraNode))]
    internal class RenderCameraNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}
﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Set FOV",
        Description = "Sets the field of view of the inputted Camera.",
        Category = "Camera",
        Color = Teal
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class SetCameraFOVNode : IONode<UnityEngine.Camera>
    {
        [SerializeField] [Range(0.001f, 179.999f)]
        private float fov = 60f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private UnityEngine.Camera _camera;
        
        protected override void OnStart(in UnityEngine.Camera camera)
        {
            if (camera == null)
                throw new JungleException("Inputted Camera is null.");
            
            _camera = camera;
            
            if (!overTime.enabled)
            {
                _camera.fieldOfView = fov;
                CallAndStop(_camera);
            }
        }
        
        protected override void OnUpdate()
        {
            if (_camera.fieldOfView == fov)
            {
                CallAndStop(_camera);
                return;
            }
            
            _camera.fieldOfView = overTime.SetFloatOverTime(_camera.fieldOfView, fov);
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetCameraFOVNode))]
    internal class SetCameraFOVNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _fov;
        private SerializedProperty _overTime;
        
        private void OnEnable()
        {
            _fov = serializedObject.FindProperty("fov");
            _overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_fov);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Set Camera State",
        Description = "Sets the enable state of the inputted Camera.",
        Category = "Camera",
        Color = Teal
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class SetCameraStateNode : IONode<UnityEngine.Camera>
    {
        [SerializeField]
        private bool enabled = true;
        
        protected override void OnStart(in UnityEngine.Camera camera)
        {
            if (camera == null)
                throw new JungleException("Inputted camera is null.");
            
            camera.enabled = enabled;
            CallAndStop(camera);
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(SetCameraStateNode))]
    internal class SetCameraStateNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _enabled;
        
        private void OnEnable()
        {
            _enabled = serializedObject.FindProperty("enabled");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_enabled);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Set Far Clip Plane",
        Description = "Sets the far clipping plane of the inputted Camera.",
        Category = "Camera",
        Color = Teal
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class SetFarClipPlaneNode : IONode<UnityEngine.Camera>
    {
        [SerializeField]
        private float far = 1000f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;

        [NonSerialized] 
        private UnityEngine.Camera _camera;
        
        protected override void OnStart(in UnityEngine.Camera inputValue)
        {
            if (inputValue == null)
                throw new JungleException("Inputted Camera is null.");
            
            _camera = inputValue;
            
            if (!overTime.enabled)
            {
                _camera.farClipPlane = far;
                CallAndStop(_camera);
            }
        }

        protected override void OnUpdate()
        {
            if (_camera.farClipPlane == far)
            {
                CallAndStop(_camera);
                return;
            }
            
            _camera.farClipPlane = overTime.SetFloatOverTime(_camera.farClipPlane, far);
        }
        
        protected override string[] OnValidation()
        {
            far = Mathf.Clamp(far, 0.02f, Mathf.Infinity);
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetFarClipPlaneNode))]
    internal class SetFarClipPlaneNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _far;
        private SerializedProperty _overTime;
        
        private void OnEnable()
        {
            _far = serializedObject.FindProperty("far");
            _overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_far);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Camera
{
    [NodeProperties(
        Title = "Set Near Clip Plane",
        Description = "Sets the near clipping plane of the inputted Camera.",
        Category = "Camera",
        Color = Teal
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Camera)
    )]
    internal class SetNearClipPlaneNode : IONode<UnityEngine.Camera>
    {
        [SerializeField]
        private float near = 0.3f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;

        [NonSerialized] 
        private UnityEngine.Camera _camera;
        
        protected override void OnStart(in UnityEngine.Camera camera)
        {
            if (camera == null)
                throw new JungleException("Inputted camera is null.");
            
            _camera = camera;
            
            if (!overTime.enabled)
            {
                _camera.nearClipPlane = near;
                CallAndStop(_camera);
            }
        }
        
        protected override void OnUpdate()
        {
            if (_camera.nearClipPlane == near)
            {
                CallAndStop(_camera);
                return;
            }
                
            _camera.nearClipPlane = overTime.SetFloatOverTime(_camera.nearClipPlane, near);
        }
        
        protected override string[] OnValidation()
        {
            near = Mathf.Clamp(near, 0.01f, Mathf.Infinity);
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetNearClipPlaneNode))]
    internal class SetNearClipPlaneNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _near;
        private SerializedProperty _overTime;

        private void OnEnable()
        {
            _near = serializedObject.FindProperty("near");
            _overTime = serializedObject.FindProperty("overTime");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_near);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Editor
{
    [NodeProperties(
        Title = "Debug Draw",
        Description = "Draws a line/ray gizmo in the scene.",
        Category = "Editor", 
        Color = Violet
    )]
    [GenericNode(
        InputPortName = "Draw",
        OutputPortName = "Done"
    )]
    internal class DebugDrawNode : GenericNode
    {
        [SerializeField] 
        private float duration = 1f;
        
        [SerializeField] 
        private Color color = Color.red;
        
        [SerializeField] 
        private Type type = Type.Line;

        [SerializeField] 
        private Vector3 startPosition;

        [SerializeField] 
        private Vector3 endPosition = Vector3.up;
        
        [SerializeField] 
        private Vector3 direction = Vector3.forward;

        [NonSerialized] 
        private float _startTime;
        
        private enum Type
        {
            Line,
            Ray
        }

        protected override void OnStart()
        {
#if UNITY_EDITOR
            switch (type)
            {
                case Type.Line:
                    Debug.DrawLine(startPosition, endPosition, color, duration);
                    break;
                case Type.Ray:
                    Debug.DrawRay(startPosition, direction, color, duration);
                    break;
            }
#endif
            _startTime = UnityEngine.Time.unscaledTime;
        }
        
        protected override void OnUpdate()
        {
            if (UnityEngine.Time.unscaledTime - _startTime >= duration)
                CallAndStop();
        }

        protected override string[] OnValidation()
        {
            duration = Mathf.Clamp(duration, 0.01f, Mathf.Infinity);
            
            var issues = new List<string>();
            switch (type)
            {
                case Type.Line:
                    if (startPosition == endPosition)
                    {
                        issues.Add("Start and end positions are the same.");
                    }
                    break;
                case Type.Ray:
                    if (direction == Vector3.zero)
                    {
                        issues.Add("Direction is zero.");
                    }
                    break;
            }
            return issues.ToArray();
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(DebugDrawNode))]
    internal class DebugDrawNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _duration;
        private SerializedProperty _color;
        private SerializedProperty _type;
        private SerializedProperty _startPosition;
        private SerializedProperty _endPosition;
        private SerializedProperty _direction;

        private void OnEnable()
        {
            _duration = serializedObject.FindProperty("duration");
            _color = serializedObject.FindProperty("color");
            _type = serializedObject.FindProperty("type");
            _startPosition = serializedObject.FindProperty("startPosition");
            _endPosition = serializedObject.FindProperty("endPosition");
            _direction = serializedObject.FindProperty("direction");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_duration);
            EditorGUILayout.PropertyField(_color);
            GUILayout.Space(5);
            EditorGUILayout.PropertyField(_type);
            GUILayout.BeginHorizontal();
            
                GUILayout.Space(10);
                GUILayout.BeginVertical();
                
                    EditorGUILayout.PropertyField(_startPosition);
                    if (_type.enumValueFlag == 0)
                    {
                        EditorGUILayout.PropertyField(_endPosition);
                    }
                    else
                    {
                        EditorGUILayout.PropertyField(_direction);
                    }
                    
                GUILayout.EndVertical();
                
            GUILayout.EndHorizontal();
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Editor
{
    [NodeProperties(
        Title = "Debug Log",
        Description = "Prints a message in the console.",
        Category = "Editor", 
        Color = Violet
    )]
    [GenericNode(
        InputPortName = "Write",
        OutputPortName = ""
    )]
    internal class DebugLogNode : GenericNode
    {
        [SerializeField] [TextArea]
        private string message;
        
        [SerializeField] 
        private Type type = Type.Log;
        
        private enum Type
        {
            Log,
            Warning,
            Error
        }
        
        protected override void OnStart()
        {
#if UNITY_EDITOR
            var completeMessage = $"[<b>{JungleTree.name}</b>] > [<b>{name}</b>]\n{message}";
            switch (type)
            {
                case Type.Log:
                    Debug.Log(completeMessage);
                    break;
                case Type.Warning:
                    Debug.LogWarning(completeMessage);
                    break;
                case Type.Error:
                    Debug.LogError(completeMessage);
                    break;
            }
#endif
            CallAndStop();
        }
        
        protected override void OnUpdate() { }

        protected override string[] OnValidation()
        {
            if (string.IsNullOrWhiteSpace(message))
                return new[] { "Debug message is empty." };
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(DebugLogNode))]
    internal class DebugLogNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _message;
        private SerializedProperty _type;
        
        private void OnEnable()
        {
            _message = serializedObject.FindProperty("message");
            _type = serializedObject.FindProperty("type");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_message);
            EditorGUILayout.PropertyField(_type);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Clone Game Object",
        Description = "Clones the inputted game object.",
        Category = "Game Object",
        Color = Blue
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "Clone",
        OutputPortType = typeof(UnityEngine.GameObject)
    )]
    internal class CloneGameObjectNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject == null)
                throw new JungleException("Inputted game object is null.");
            
            // Try instantiate the inputted game object
            var clone = Instantiate(gameObject);
            
            if (clone == null)
                throw new JungleException("Failed to clone inputted game object.");
            
            CallAndStop(new Port.Call(0, clone));
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(CloneGameObjectNode))]
    internal class CloneGameObjectNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}
﻿namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Destroy Game Object",
        Description = "Destroys the game object.",
        Category = "Game Object",
        Color = Blue
    )]
    [IONode(
        InputPortName = "Destroy",
        OutputPortName = "",
        OutputPortType = typeof(Port.None)
    )]
    internal class DestroyGameObjectNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject == null)
                throw new JungleException("Inputted game object is null.");
            
            Destroy(gameObject);
            CallAndStop(new Port.None());
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(DestroyGameObjectNode))]
    internal class DestroyGameObjectNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Find Game Object",
        Description = "Finds a game object in the scene by name or tag.",
        Category = "Game Object",
        Color = Blue
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.GameObject)
    )]
    internal class FindGameObjectNode : IONode<Port.None>
    {
        [SerializeField] 
        private FindByMethod findByMethod = FindByMethod.ByName;
        
        [SerializeField] 
        private string gameObjectName;

        [SerializeField] 
        private string gameObjectTag;

        private enum FindByMethod
        {
            ByName,
            ByTag
        }
        
        protected override void OnStart(in Port.None _)
        {
            if (findByMethod == FindByMethod.ByName)
            {
                if (string.IsNullOrEmpty(gameObjectName))
                    throw new JungleException("Trying to find game object by name but the name is empty.");
                
                var foundGameObject = UnityEngine.GameObject.Find(gameObjectName);
                
                if (foundGameObject == null)
                    throw new JungleException($"Failed to find game object by name \"{gameObjectName}\"");
                
                CallAndStop(foundGameObject);
            }
            else if (findByMethod == FindByMethod.ByTag)
            {
                if (string.IsNullOrEmpty(gameObjectTag))
                    throw new JungleException("Trying to find game object by tag but the tag is empty.");
                
                var foundGameObject = UnityEngine.GameObject.FindWithTag(gameObjectTag);
                
                if (foundGameObject == null)
                    throw new JungleException($"Failed to find game object with tag \"{gameObjectTag}\"");
                
                CallAndStop(foundGameObject);
            }
        }
        
        protected override void OnUpdate() { }
        
        public override string GetDetails()
        {
            switch (findByMethod)
            {
                case FindByMethod.ByName when !string.IsNullOrEmpty(gameObjectName):
                    return $"Get Game Object with name <b>\"{gameObjectName}\"</b>";
                case FindByMethod.ByTag when !string.IsNullOrEmpty(gameObjectTag):
                    return $"Get Game Object with tag <b>\"{gameObjectTag}\"</b>";
            }
            return null;
        }
        
        protected override string[] OnValidation()
        {
            var issues = new List<string>();
            switch (findByMethod)
            {
                case FindByMethod.ByName when string.IsNullOrEmpty(gameObjectName):
                    issues.Add("Trying to find game object by name but the name is empty.");
                    break;
                case FindByMethod.ByTag when string.IsNullOrEmpty(gameObjectTag):
                    issues.Add("Trying to find game object by tag but the tag is empty.");
                    break;
            }
            return issues.ToArray();
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(FindGameObjectNode))]
    internal class FindGameObjectNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _findMethod;
        private SerializedProperty _gameObjectName;
        private SerializedProperty _gameObjectTag;

        private void OnEnable()
        {
            _findMethod = serializedObject.FindProperty("findByMethod");
            _gameObjectName = serializedObject.FindProperty("gameObjectName");
            _gameObjectTag = serializedObject.FindProperty("gameObjectTag");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_findMethod);
            GUILayout.BeginHorizontal();
                GUILayout.Space(10);
                GUILayout.BeginVertical();
                    EditorGUILayout.PropertyField(_findMethod.enumValueFlag == 0 ? _gameObjectName : _gameObjectTag);
                GUILayout.EndVertical();
            GUILayout.EndHorizontal();
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Send Message",
        Description = "Sends a message to a Mono Behaviour script on the inputted Game Object.",
        Category = "Game Object",
        Color = Violet
    )]
    [IONode(
        InputPortName = "Send",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.GameObject)
    )]
    internal class SendMessageNode : IONode<UnityEngine.GameObject>
    {
        [SerializeField] [Tooltip("The name of the method to call.")]
        private string methodName = "MyMethod";

        [SerializeField] [Tooltip("The type of parameter to pass to the method.")]
        private ParameterType parameterType = ParameterType.None;

        [SerializeField] [Tooltip("The integer parameter to pass to the method.")]
        private int intParameter = 1;
        
        [SerializeField] [Tooltip("The float parameter to pass to the method.")]
        private float floatParameter = 1f;
        
        [SerializeField] [Tooltip("The string parameter to pass to the method.")]
        private string stringParameter = "MyString";
        
        [SerializeField] [Tooltip("The boolean parameter to pass to the method.")]
        private bool boolParameter = true;
        
        [SerializeField] [Tooltip("The object parameter to pass to the method.")]
        private Object objectParameter;
        
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (string.IsNullOrEmpty(methodName))
                throw new JungleException("Trying to send a message with no method name.");
            
            if (gameObject == null)
                throw new JungleException("Inputted Game Object was null.");
            
            switch (parameterType)
            {
                case ParameterType.None:
                    gameObject.SendMessage(methodName, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Int:
                    gameObject.SendMessage(methodName, intParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Float:
                    gameObject.SendMessage(methodName, floatParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.String:
                    gameObject.SendMessage(methodName, stringParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Bool:
                    gameObject.SendMessage(methodName, boolParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Object:
                    gameObject.SendMessage(methodName, objectParameter, SendMessageOptions.DontRequireReceiver);
                    break;
            }
            
            CallAndStop(gameObject);
        }
        
        protected override void OnUpdate() { }
        
        public override string GetDetails()
        {
            if (string.IsNullOrEmpty(methodName))
                return null;
            
            switch (parameterType)
            {
                case ParameterType.None:
                    return $"Send message <b>\"{methodName }\"</b> upwards with <b>NO</b> data";
                case ParameterType.Int:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{intParameter}</b>";
                case ParameterType.Float:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{floatParameter}f</b>";
                case ParameterType.String:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>\"{stringParameter}\"</b>";
                case ParameterType.Bool:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{boolParameter}</b>";
                case ParameterType.Object:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>Object named \"{(objectParameter != null ? objectParameter.name : "Unknown")}\"</b>";
            }
            
            return null;
        }
        
        protected override string[] OnValidation()
        {
            var issues = new List<string>();
            if (string.IsNullOrEmpty(methodName))
            {
                issues.Add("Trying to send a message with no method name.");
            }
            return issues.ToArray();
        }
    }
    
    internal enum ParameterType
    {
        None,
        Int,
        Float,
        String,
        Bool,
        Object
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SendMessageNode))]
    internal class SendMessageNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _methodName;
        private SerializedProperty _parameterType;
        private SerializedProperty _intParameter;
        private SerializedProperty _floatParameter;
        private SerializedProperty _stringParameter;
        private SerializedProperty _boolParameter;
        private SerializedProperty _objectParameter;
        
        private void OnEnable()
        {
            _methodName = serializedObject.FindProperty("methodName");
            _parameterType = serializedObject.FindProperty("parameterType");
            _intParameter = serializedObject.FindProperty("intParameter");
            _floatParameter = serializedObject.FindProperty("floatParameter");
            _stringParameter = serializedObject.FindProperty("stringParameter");
            _boolParameter = serializedObject.FindProperty("boolParameter");
            _objectParameter = serializedObject.FindProperty("objectParameter");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_methodName);
            EditorGUILayout.PropertyField(_parameterType);
            switch ((ParameterType) _parameterType.enumValueIndex)
            {
                case ParameterType.None:
                    break;
                case ParameterType.Int:
                    EditorGUILayout.PropertyField(_intParameter);
                    break;
                case ParameterType.Float:
                    EditorGUILayout.PropertyField(_floatParameter);
                    break;
                case ParameterType.String:
                    EditorGUILayout.PropertyField(_stringParameter);
                    break;
                case ParameterType.Bool:
                    EditorGUILayout.PropertyField(_boolParameter);
                    break;
                case ParameterType.Object:
                    EditorGUILayout.PropertyField(_objectParameter);
                    break;
            }
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System.Collections.Generic;
using UnityEngine;
using Object = UnityEngine.Object;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Send Message Upwards",
        Description = "Sends a message to all Mono Behaviour scripts on the inputted Game Object.",
        Category = "Game Object",
        Color = Violet
    )]
    [IONode(
        InputPortName = "Send",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.GameObject)
    )]
    internal class SendMessageUpwardsNode : IONode<UnityEngine.GameObject>
    {
        [SerializeField] [Tooltip("The name of the method to call.")]
        private string methodName = "MyMethod";
        
        [SerializeField] [Tooltip("The type of parameter to pass to the method.")]
        private ParameterType parameterType = ParameterType.None;

        [SerializeField] [Tooltip("The integer parameter to pass to the method.")]
        private int intParameter = 1;
        
        [SerializeField] [Tooltip("The float parameter to pass to the method.")]
        private float floatParameter = 1f;
        
        [SerializeField] [Tooltip("The string parameter to pass to the method.")]
        private string stringParameter = "MyString";
        
        [SerializeField] [Tooltip("The boolean parameter to pass to the method.")]
        private bool boolParameter = true;
        
        [SerializeField] [Tooltip("The object parameter to pass to the method.")]
        private Object objectParameter;
        
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (string.IsNullOrEmpty(methodName))
                throw new JungleException("Trying to send a message upwards with no method name.");
            
            if (gameObject == null)
                throw new JungleException("Inputted Game Object was null.");
            
            switch (parameterType)
            {
                case ParameterType.None:
                    gameObject.SendMessage(methodName, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Int:
                    gameObject.SendMessage(methodName, intParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Float:
                    gameObject.SendMessage(methodName, floatParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.String:
                    gameObject.SendMessage(methodName, stringParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Bool:
                    gameObject.SendMessage(methodName, boolParameter, SendMessageOptions.DontRequireReceiver);
                    break;
                case ParameterType.Object:
                    gameObject.SendMessage(methodName, objectParameter, SendMessageOptions.DontRequireReceiver);
                    break;
            }
            
            CallAndStop(gameObject);
        }

        protected override void OnUpdate() { }

        public override string GetDetails()
        {
            if (string.IsNullOrEmpty(methodName))
                return null;
            
            switch (parameterType)
            {
                case ParameterType.None:
                    return $"Send message <b>\"{methodName }\"</b> upwards with <b>NO</b> data";
                case ParameterType.Int:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{intParameter}</b>";
                case ParameterType.Float:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{floatParameter}f</b>";
                case ParameterType.String:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>\"{stringParameter}\"</b>";
                case ParameterType.Bool:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>{boolParameter}</b>";
                case ParameterType.Object:
                    return $"Send message <b>\"{methodName}\"</b> upwards with parameter: " +
                           $"<b>Object named \"{(objectParameter != null ? objectParameter.name : "Unknown")}\"</b>";
            }
            
            return null;
        }
        
        protected override string[] OnValidation()
        {
            var issues = new List<string>();
            if (string.IsNullOrEmpty(methodName))
            {
                issues.Add("Trying to send a message upwards with no method name.");
            }
            return issues.ToArray();
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SendMessageUpwardsNode))]
    internal class SendMessageUpwardsNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _methodName;
        private SerializedProperty _parameterType;
        private SerializedProperty _intParameter;
        private SerializedProperty _floatParameter;
        private SerializedProperty _stringParameter;
        private SerializedProperty _boolParameter;
        private SerializedProperty _objectParameter;
        
        private void OnEnable()
        {
            _methodName = serializedObject.FindProperty("methodName");
            _parameterType = serializedObject.FindProperty("parameterType");
            _intParameter = serializedObject.FindProperty("intParameter");
            _floatParameter = serializedObject.FindProperty("floatParameter");
            _stringParameter = serializedObject.FindProperty("stringParameter");
            _boolParameter = serializedObject.FindProperty("boolParameter");
            _objectParameter = serializedObject.FindProperty("objectParameter");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_methodName);
            EditorGUILayout.PropertyField(_parameterType);
            switch ((ParameterType) _parameterType.enumValueIndex)
            {
                case ParameterType.None:
                    break;
                case ParameterType.Int:
                    EditorGUILayout.PropertyField(_intParameter);
                    break;
                case ParameterType.Float:
                    EditorGUILayout.PropertyField(_floatParameter);
                    break;
                case ParameterType.String:
                    EditorGUILayout.PropertyField(_stringParameter);
                    break;
                case ParameterType.Bool:
                    EditorGUILayout.PropertyField(_boolParameter);
                    break;
                case ParameterType.Object:
                    EditorGUILayout.PropertyField(_objectParameter);
                    break;
            }
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;

namespace Jungle.Nodes.GameObject
{
    [NodeProperties(
        Title = "Set Game Object State",
        Description = "Sets the inputted game objects active state.",
        Category = "Game Object",
        Color = Blue
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.GameObject)
    )]
    internal class SetGameObjectStateNode : IONode<UnityEngine.GameObject>
    {
        [SerializeField]
        private bool setToState = true;
        
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject == null)
                throw new JungleException("Inputted game object is null.");
            
            gameObject.SetActive(setToState);
            CallAndStop(gameObject);
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(SetGameObjectStateNode))]
    internal class SetGameObjectStateNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}
﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Add Force",
        Description = "Adds a force to the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = Red
    )]
    [BranchNode(
        InputPortName = "Add",
        OutputPortNames = new []{ "Start", "Done" },
        OutputPortTypes = new []{ typeof(Rigidbody), typeof(Rigidbody) }
    )]
    public class AddForceNode : BranchNode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private Vector3 force = Vector3.up;
        
        [SerializeField]
        private ForceMode mode = ForceMode.Force;
        
        [SerializeField]
        private float duration = 1f;

        [SerializeField] 
        private bool scaledTime = true;
        
        [NonSerialized]
        private Rigidbody _rigidbody;

        [NonSerialized] 
        private float _startTime;
        
        #endregion

        protected override void OnStart(in Rigidbody inputValue)
        {
            _rigidbody = inputValue as Rigidbody;
            if (_rigidbody == null)
            {
                CallAndStop(new[]
                {
                    new Port.Call(0, null)
                });
                return;
            }

            if (mode is ForceMode.Impulse or ForceMode.VelocityChange)
            {
                _rigidbody.AddForce(force, mode);
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
            else _startTime = scaledTime ? UnityEngine.Time.time : UnityEngine.Time.unscaledTime;
        }
        
        protected override void OnUpdate()
        {
            _rigidbody.AddForce(force, mode);
            if ((scaledTime ? UnityEngine.Time.time : UnityEngine.Time.unscaledTime) - _startTime >= duration)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
        }
        
        protected override string[] OnValidation()
        {
            if (duration < 0.01f)
                duration = 0.01f;
            return Array.Empty<string>();
        }
    }
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Add Torque",
        Description = "Adds torque to the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = Red
    )]
    [BranchNode(
        InputPortName = "Add",
        OutputPortNames = new []{ "Start", "Done" },
        OutputPortTypes = new []{ typeof(Rigidbody), typeof(Rigidbody) }
    )]
    public class AddTorqueNode : BranchNode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private Vector3 torque = Vector3.forward;
        
        [SerializeField]
        private ForceMode mode = ForceMode.Force;
        
        [SerializeField]
        private float duration = 1f;

        [SerializeField] 
        private bool scaledTime = true;
        
        [NonSerialized]
        private Rigidbody _rigidbody;

        [NonSerialized] 
        private float _startTime;
        
        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            _rigidbody = inputValue as Rigidbody;
            if (_rigidbody == null)
            {
                CallAndStop(new[]
                {
                    new Port.Call(0, null)
                });
                return;
            }

            if (mode is ForceMode.Impulse or ForceMode.VelocityChange)
            {
                _rigidbody.AddTorque(torque, mode);
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
            else _startTime = scaledTime ? UnityEngine.Time.time : UnityEngine.Time.unscaledTime;
        }

        protected override void OnUpdate()
        {
            _rigidbody.AddTorque(torque, mode);
            if ((scaledTime ? UnityEngine.Time.time : UnityEngine.Time.unscaledTime) - _startTime >= duration)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
        }
        
        protected override string[] OnValidation()
        {
            if (duration < 0.01f)
                duration = 0.01f;
            return Array.Empty<string>();
        }
    }
}

﻿using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Get Rigidbody",
        Description = "Gets the Rigidbody of the inputted GameObject.",
        Category = "Physics/3D",
        Color = Red
    )]
    [IONode(
        InputPortName = "Get",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    internal class GetRigidbodyNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject == null)
                throw new JungleException("Inputted GameObject is null.");
            
            gameObject.TryGetComponent<Rigidbody>(out var rigidbody);
            
            if (rigidbody == null)
                throw new JungleException("Inputted GameObject does not have a Rigidbody component.");
            
            CallAndStop(rigidbody);
        }
        
        protected override void OnUpdate() { }
    }

#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(GetRigidbodyNode))]
    internal class GetRigidbodyNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Angular Drag",
        Description = "Sets the angular drag of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetAngularDragNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private float angularDrag = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Rigidbody _rigidbody;

        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            _rigidbody = inputValue as Rigidbody;
            if (_rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _rigidbody.angularDrag = overTime.SetFloatOverTime(_rigidbody.angularDrag, angularDrag);
                if (_rigidbody.angularDrag == angularDrag)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _rigidbody)
                    });
                }
            }
            else
            {
                _rigidbody.angularDrag = angularDrag;
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
        }
    }
}

﻿using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Center Of Mass",
        Description = "Sets the center of mass of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetCenterOfMassNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private Vector3 centerOfMass = Vector3.zero;
        
        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            var rigidbody = inputValue as Rigidbody;
            if (rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                rigidbody.centerOfMass = centerOfMass;
                CallAndStop(new []
                {
                    new Port.Call(0, rigidbody)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Drag",
        Description = "Sets the drag of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetDragNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private float drag = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Rigidbody _rigidbody;

        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            _rigidbody = inputValue as Rigidbody;
            if (_rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _rigidbody.drag = overTime.SetFloatOverTime(_rigidbody.drag, drag);
                if (_rigidbody.drag == drag)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _rigidbody)
                    });
                }
            }
            else
            {
                _rigidbody.drag = drag;
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
        }
    }
}
﻿using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Gravity",
        Description = "Sets the gravity of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetGravityNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private bool useGravity = true;

        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            var rigidbody = inputValue as Rigidbody;
            if (rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                rigidbody.useGravity = useGravity;
                CallAndStop(new []
                {
                    new Port.Call(0, rigidbody)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Kinematic",
        Description = "Sets the kinematic state of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetKinematicNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private bool isKinematic = true;

        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            var rigidbody = inputValue as Rigidbody;
            if (rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                rigidbody.isKinematic = isKinematic;
                CallAndStop(new []
                {
                    new Port.Call(0, rigidbody)
                });
            }
        }

        protected override void OnUpdate()
        {
            
        }
    }
}

﻿using System;
using UnityEngine;

namespace Jungle.Nodes.Physics._3d
{
    [NodeProperties(
        Title = "Set Mass",
        Description = "Sets the mass of the inputted Rigidbody.",
        Category = "Physics/3D",
        Color = "#8c0000"
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "",
        OutputPortType = typeof(Rigidbody)
    )]
    public class SetMassNode : IONode<Rigidbody>
    {
        #region Variables

        [SerializeField]
        private float mass = 1f;

        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        [NonSerialized]
        private Rigidbody _rigidbody;
        
        #endregion
        
        protected override void OnStart(in Rigidbody inputValue)
        {
            _rigidbody = inputValue as Rigidbody;
            if (_rigidbody == null)
            {
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
        }
        
        protected override void OnUpdate()
        {
            if (overTime.enabled)
            {
                _rigidbody.mass = overTime.SetFloatOverTime(_rigidbody.mass, mass);
                if (_rigidbody.mass == mass)
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, _rigidbody)
                    });
                }
            }
            else
            {
                _rigidbody.mass = mass;
                CallAndStop(new []
                {
                    new Port.Call(0, _rigidbody)
                });
            }
        }

        protected override string[] OnValidation()
        {
            if (mass < 0.0000001f)
                mass = 0.0000001f;
            return Array.Empty<string>();
        }
    }
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Physics
{
    [NodeProperties(
        Title = "Set Global Gravity",
        Description = "Sets the gravity of the physics system.",
        Category = "Physics",
        Color = Red
    )]
    [GenericNode(
        InputPortName = "Set",
        OutputPortName = "Done"
    )]
    internal class SetGlobalGravityNode : GenericNode
    {
        [SerializeField]
        private Vector3 gravity = new(0f, -9.81f, 0f);
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        protected override void OnStart()
        {
            if (!overTime.enabled)
            {
                UnityEngine.Physics.gravity = gravity;
                CallAndStop();
            }
        }
        
        protected override void OnUpdate()
        {
            UnityEngine.Physics.gravity = overTime.SetVector3OverTime
            (
                UnityEngine.Physics.gravity,
                gravity
            );
            
            if (UnityEngine.Physics.gravity == gravity)
                CallAndStop();
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetGlobalGravityNode))]
    internal class SetGlobalGravityNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _gravity;
        private SerializedProperty _overTime;
        
        private void OnEnable()
        {
            _gravity = serializedObject.FindProperty("gravity");
            _overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_gravity);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿namespace Jungle.Nodes
{
    [NodeProperties(
        Title = "Start", 
        Description = "Called each time the Jungle Tree is started. Serves as the entry point.",
        Category = "None of your business",
        Color = Green
    )]
    [EventNode(
        OutputPortNames = new []{ "" },
        OutputPortTypes = new []{ typeof(Port.None) }
    )]
    public class StartNode : EventNode
    {
        protected override void OnStart()
        {
            CallAndStop(new Port.Call(0, new Port.None()));
        }
        
        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(StartNode))]
    internal class StartNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Time
{
    [NodeProperties(
        Title = "Set Fixed Timestep", 
        Description = "Sets the fixed timestep.",
        Category = "Time",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Set",
        OutputPortName = "Done"
    )]
    internal class SetFixedTimestepNode : GenericNode
    {
        [SerializeField]
        private float fixedTimestep = 0.02f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        protected override void OnStart()
        {
            if (!overTime.enabled)
            {
                UnityEngine.Time.fixedDeltaTime = fixedTimestep;
                CallAndStop();
            }
        }
        
        protected override void OnUpdate()
        {
            if (UnityEngine.Time.fixedDeltaTime == fixedTimestep)
            {
                CallAndStop();
                return;
            }
            
            UnityEngine.Time.fixedDeltaTime = overTime.SetFloatOverTime
            (
                UnityEngine.Time.fixedDeltaTime,
                fixedTimestep
            );
        }
        
        protected override string[] OnValidation()
        {
            fixedTimestep = Mathf.Clamp(fixedTimestep, 0f, Mathf.Infinity);
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetFixedTimestepNode))]
    internal class SetFixedTimestepNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _fixedTimestep;
        private SerializedProperty _overTime;
        
        private void OnEnable()
        {
            _fixedTimestep = serializedObject.FindProperty("fixedTimestep");
            _overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_fixedTimestep);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Time
{
    [NodeProperties(
        Title = "Set Time Scale", 
        Description = "Sets the time scale.",
        Category = "Time",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Set",
        OutputPortName = "Done"
    )]
    internal class SetTimeScaleNode : GenericNode
    {
        [SerializeField]
        private float timeScale = 1f;
        
        [SerializeField]
        private OverTimeHelper overTime = OverTimeHelper.Default;
        
        protected override void OnStart()
        {
            if (!overTime.enabled)
            {
                UnityEngine.Time.timeScale = timeScale;
                CallAndStop();
            }
        }

        protected override void OnUpdate()
        {
            if (UnityEngine.Time.timeScale == timeScale)
            {
                CallAndStop();
                return;
            }
            
            UnityEngine.Time.timeScale = overTime.SetFloatOverTime
            (
                UnityEngine.Time.timeScale,
                timeScale
            );
        }
        
        protected override string[] OnValidation()
        {
            timeScale = Mathf.Clamp(timeScale, 0f, Mathf.Infinity);
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetTimeScaleNode))]
    internal class SetTimeScaleNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _timeScale;
        private SerializedProperty _overTime;
        
        private void OnEnable()
        {
            _timeScale = serializedObject.FindProperty("timeScale");
            _overTime = serializedObject.FindProperty("overTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_timeScale);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Time
{
    [NodeProperties(
        Title = "Wait For Frames", 
        Description = "Waits for the specified amount of frames.",
        Category = "Time",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Begin",
        OutputPortName = "Elapsed"
    )]
    internal class WaitForFramesNode : GenericNode
    {
        [SerializeField] 
        private int duration = 100;

        [NonSerialized]
        private int _elapsedFrames;
        
        protected override void OnStart()
        {
            _elapsedFrames = 0;
        }

        protected override void OnUpdate()
        {
            if (_elapsedFrames >= duration)
            {
                CallAndStop();
                return;
            }
            _elapsedFrames++;
        }
        
        protected override string[] OnValidation()
        {
            duration = (int)Mathf.Clamp(duration, 1, Mathf.Infinity);
            return Array.Empty<string>();
        }
        
        public override string GetDetails()
        {
            return $"Wait for <b>{duration}</b> frame" + (duration == 1 ? "" : "s");
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(WaitForFramesNode))]
    internal class WaitForFramesNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _duration;

        private void OnEnable()
        {
            _duration = serializedObject.FindProperty("duration");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            GUILayout.BeginHorizontal();
            
                EditorGUILayout.PropertyField(_duration);
                GUI.enabled = false;
                GUILayout.Label("Frame(s)");
                GUI.enabled = true;
            
            GUILayout.EndHorizontal();
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Time
{
    [NodeProperties(
        Title = "Wait For Minutes",
        Description = "Waits for the specified amount of minutes.",
        Category = "Time",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Start",
        OutputPortName = "Elapsed"
    )]
    internal class WaitForMinutesNode : GenericNode
    {
        [SerializeField] 
        private float duration = 1;
        
        [SerializeField]
        private bool scaledTime = true;
        
        [NonSerialized]
        private float _startTime;
        [NonSerialized]
        private bool _useScaledTime;
        
        protected override void OnStart()
        {
            _useScaledTime = scaledTime;
            _startTime = _useScaledTime
                ? UnityEngine.Time.time
                : UnityEngine.Time.unscaledTime;
        }

        protected override void OnUpdate()
        {
            var currentTime = _useScaledTime
                ? UnityEngine.Time.time
                : UnityEngine.Time.unscaledTime;
            
            if (duration * 60 > currentTime - _startTime)
                return;
            
            CallAndStop();
        }
        
        protected override string[] OnValidation()
        {
            duration = Mathf.Clamp(duration, 0.001f, Mathf.Infinity);
            return Array.Empty<string>();
        }
        
        public override string GetDetails()
        {
            return $"Wait for <b>{duration}</b> minute" + (duration == 1 ? "" : "s");
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(WaitForMinutesNode))]
    internal class WaitForMinutesNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _duration;
        private SerializedProperty _scaledTime;
        
        private void OnEnable()
        {
            _duration = serializedObject.FindProperty("duration");
            _scaledTime = serializedObject.FindProperty("scaledTime");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            GUILayout.BeginHorizontal();
            
                EditorGUILayout.PropertyField(_duration);
                GUI.enabled = false;
                GUILayout.Label("Minute(s)");
                GUI.enabled = true;
                
            GUILayout.EndHorizontal();
            EditorGUILayout.PropertyField(_scaledTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}
﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Time
{
    [NodeProperties(
        Title = "Wait For Seconds",
        Description = "Waits for the specified amount of seconds.",
        Category = "Time",
        Color = Yellow
    )]
    [GenericNode(
        InputPortName = "Start",
        OutputPortName = "Elapsed"
    )]
    internal class WaitForSecondsNode : GenericNode
    {
        [SerializeField] 
        private float duration = 1f;

        [SerializeField]
        private bool scaledTime = true;
        
        [NonSerialized]
        private float _startTime;
        [NonSerialized]
        private bool _useScaledTime;

        protected override void OnStart()
        {
            _useScaledTime = scaledTime;
            _startTime = _useScaledTime
                ? UnityEngine.Time.time
                : UnityEngine.Time.unscaledTime;
        }

        protected override void OnUpdate()
        {
            var currentTime = _useScaledTime
                ? UnityEngine.Time.time
                : UnityEngine.Time.unscaledTime;
            
            if (duration > currentTime - _startTime)
                return;
            
            CallAndStop();
        }

        protected override string[] OnValidation()
        {
            duration = Mathf.Clamp(duration, 0.001f, Mathf.Infinity);
            return Array.Empty<string>();
        }

        public override string GetDetails()
        {
            return $"Wait for <b>{duration}</b> second" + (duration == 1 ? "" : "s");
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(WaitForSecondsNode))]
    internal class WaitForSecondsNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _duration;
        private SerializedProperty _scaledTime;
        
        private void OnEnable()
        {
            _duration = serializedObject.FindProperty("duration");
            _scaledTime = serializedObject.FindProperty("scaledTime");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            GUILayout.BeginHorizontal();
            
                EditorGUILayout.PropertyField(_duration);
                GUI.enabled = false;
                GUILayout.Label("Second(s)");
                GUI.enabled = true;
            
            GUILayout.EndHorizontal();
            EditorGUILayout.PropertyField(_scaledTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Find Child",
        Description = "Finds the child of the inputted Transform with a specific name.",
        Category = "Transform",
        Color = Green
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "Child",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class FindChildNode : IONode<UnityEngine.Transform>
    {
        [SerializeField] 
        private string childName;
        
        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("Inputted Transform is null.");
            
            if (string.IsNullOrEmpty(childName))
                throw new JungleException("Child name is null or empty.");
            
            var childTransform = transform.Find(childName);

            if (childTransform == null)
            {
                throw new JungleException
                (
                    $"Inputted Transform does not have a child with the name \"{childName}\"."
                );
            }
            
            CallAndStop(childTransform);
        }
        
        protected override void OnUpdate() { }
        
        public override string GetDetails()
        {
            if (!string.IsNullOrEmpty(childName))
                return $"Find child with name <b>{childName}</b>";
            return null;
        }
        
        protected override string[] OnValidation()
        {
            if (string.IsNullOrEmpty(childName))
                return new []{ "Trying to find a child transform by name but the name is empty." };
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(FindChildNode))]
    internal class FindChildNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _childName;
        
        private void OnEnable()
        {
            _childName = serializedObject.FindProperty("childName");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_childName);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Get Child",
        Description = "Gets the child of the inputted Transform.",
        Category = "Transform",
        Color = Green
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "Child",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class GetChildNode : IONode<UnityEngine.Transform>
    {
        #region Variables
        
        [SerializeField]
        private int index;

        #endregion
        
        protected override void OnStart(in UnityEngine.Transform inputValue)
        {
            var transform = inputValue as UnityEngine.Transform;
            if (transform == null)
            {
#if UNITY_EDITOR
                Debug.LogFormat
                (
                    LogType.Error, LogOption.NoStacktrace, null, 
                    $"[Jungle] [{name}] Failed to get child because the inputted Transform was null."
                );
#endif
                CallAndStop(new []
                {
                    new Port.Call(0, null)
                });
            }
            else
            {
                var child = transform.GetChild(index);
                if (child == null)
                {
#if UNITY_EDITOR
                    Debug.LogFormat
                    (
                        LogType.Error, LogOption.NoStacktrace, null, 
                        $"[Jungle] [{name}] Failed to get child because the inputted Transform had no child at index {index}."
                    );
#endif
                    CallAndStop(new []
                    {
                        new Port.Call(0, null)
                    });
                }
                else
                {
                    CallAndStop(new []
                    {
                        new Port.Call(0, child)
                    });
                }
            }
        }
        
        protected override void OnUpdate()
        {
            
        }

        public override string GetDetails()
        {
            return $"Get child at index <b>{index}</b>";
        }

        protected override string[] OnValidation()
        {
            if (index < 0)
                index = 0;
            return Array.Empty<string>();
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(GetChildNode))]
    internal class GetChildNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty index;
        
        private void OnEnable()
        {
            index = serializedObject.FindProperty("index");
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(index);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif  
}
﻿namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Get Parent",
        Description = "Gets the parent of the inputted Transform.",
        Category = "Transform",
        Color = Green
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "Parent",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class GetParentNode : IONode<UnityEngine.Transform>
    {
        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("The inputted Transform was null.");
            
            var parent = transform.parent;
            CallAndStop(parent);
        }
        
        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(GetParentNode))]
    internal class GetParentNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Get Root",
        Description = "Gets the root transform of the inputted transform.",
        Category = "Transform",
        Color = Green
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "Root",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class GetRootNode : IONode<UnityEngine.Transform>
    {
        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("The inputted Transform was null.");
            
            var root = transform.root;
            CallAndStop(root);
        }
        
        protected override void OnUpdate() { }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(GetRootNode))]
    internal class GetRootNodeNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Get Transform",
        Description = "Gets the Transform on the inputted Game Object.",
        Category = "Transform",
        Color = Green
    )]
    [IONode(
        InputPortName = "",
        OutputPortName = "",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class GetTransformNode : IONode<UnityEngine.GameObject>
    {
        protected override void OnStart(in UnityEngine.GameObject gameObject)
        {
            if (gameObject != null)
            {
                CallAndStop(gameObject.transform);
                return;
            }
            
            // If the inputted Game Object is null, log an error and stop the node
            DebugLogError("Inputted Game Object is null.");
            Stop();
        }
        
        protected override void OnUpdate() { }
    }
    
    internal enum Space
    {
        World,
        Local
    }
    
    internal enum Method
    {
        Lerp,
        Slerp,
        MoveTowards
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(GetTransformNode))]
    internal class GetTransformNodeEditor : UnityEditor.Editor
    {
        public override void OnInspectorGUI() { }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Set Position",
        Description = "Sets the inputted transforms position.",
        Category = "Transform",
        Color = Yellow
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class SetPositionNode : IONode<UnityEngine.Transform>
    {
        [SerializeField] 
        private Vector3 position;
        
        [SerializeField]
        private Space space = Space.World;

        [SerializeField] 
        private OverTimeHelper overTime;
        
        [NonSerialized] 
        private UnityEngine.Transform _transform;
        
        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("Inputted Transform was null.");
            
            _transform = transform;

            if (!overTime.enabled)
            {
                if (space == Space.World)
                    _transform.position = position;
                else
                    _transform.localPosition = position;
                CallAndStop(_transform);
            }
        }
        
        protected override void OnUpdate()
        {
            if (_transform == null)
            {
                throw new JungleException
                (
                    "Failed to set position because the transform is null." +
                    " Did you delete its Game Object?"
                );
            }
            
            if (space == Space.World)
            {
                if (_transform.position == position)
                {
                    CallAndStop(_transform);
                    return;
                }
                _transform.position = overTime.SetVector3OverTime
                (
                    _transform.position,
                    position
                );
            }
            else if (space == Space.Local)
            {
                if (_transform.localPosition == position)
                {
                    CallAndStop(_transform);
                    return;
                }
                _transform.localPosition = overTime.SetVector3OverTime
                (
                    _transform.localPosition,
                    position
                );
            }
        }

        public override string GetDetails()
        {
            switch (space)
            {
                case Space.World:
                    return $"<b>{position.ToString()}</b>";
                case Space.Local:
                    return $"<b>{position.ToString()}</b> (Local)";
            }
            return null;
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(SetPositionNode))]
    internal class SetPositionNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _position;
        private SerializedProperty _space;
        private SerializedProperty _overTime;

        private void OnEnable()
        {
            _position = serializedObject.FindProperty("position");
            _space = serializedObject.FindProperty("space");
            _overTime = serializedObject.FindProperty("overTime");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_position);
            EditorGUILayout.PropertyField(_space);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Set Rotation",
        Description = "Sets the inputted transforms rotation. (Euler)",
        Category = "Transform",
        Color = Red
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class SetRotationNode : IONode<UnityEngine.Transform>
    {
        [SerializeField] 
        private Vector3 rotation;
        
        [SerializeField] 
        private Space space = Space.World;

        [SerializeField] 
        private OverTimeHelper overTime;
        
        [NonSerialized] 
        private UnityEngine.Transform _transform;

        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("Inputted Transform was null.");
            
            _transform = transform;

            if (!overTime.enabled)
            {
                if (space == Space.World)
                    _transform.rotation = Quaternion.Euler(rotation);
                else
                    _transform.localRotation = Quaternion.Euler(rotation);
                CallAndStop(_transform);
            }
        }

        protected override void OnUpdate()
        {
            if (_transform == null)
            {
                throw new JungleException
                (
                    "Failed to set rotation because the transform is null. " +
                    "Did you delete its Game Object?"
                );
            }
            
            if (space == Space.World)
            {
                if (_transform.rotation.eulerAngles == rotation)
                {
                    CallAndStop(_transform);
                    return;
                }
                _transform.rotation = overTime.SetQuaternionOverTime
                (
                    _transform.rotation,
                    Quaternion.Euler(rotation)
                );
            }
            else
            {
                if (_transform.localRotation.eulerAngles == rotation)
                {
                    CallAndStop(_transform);
                    return;
                }
                _transform.localRotation = overTime.SetQuaternionOverTime
                (
                    _transform.localRotation,
                    Quaternion.Euler(rotation)
                );
            }
        }
        
        public override string GetDetails()
        {
            switch (space)
            {
                case Space.World:
                    return $"<b>{rotation.ToString()}</b>";
                case Space.Local:
                    return $"<b>{rotation.ToString()}</b> (Local)";
            }
            return null;
        }
    }
    
#if UNITY_EDITOR
    [CustomEditor(typeof(SetRotationNode))]
    internal class SetRotationNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _rotation;
        private SerializedProperty _space;
        private SerializedProperty _overTime;

        private void OnEnable()
        {
            _rotation = serializedObject.FindProperty("rotation");
            _space = serializedObject.FindProperty("space");
            _overTime = serializedObject.FindProperty("overTime");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_rotation);
            EditorGUILayout.PropertyField(_space);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

﻿using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Jungle.Nodes.Transform
{
    [NodeProperties(
        Title = "Set Scale",
        Description = "Sets the inputted transforms scale.",
        Category = "Transform",
        Color = Blue
    )]
    [IONode(
        InputPortName = "Set",
        OutputPortName = "Done",
        OutputPortType = typeof(UnityEngine.Transform)
    )]
    internal class SetScaleNode : IONode<UnityEngine.Transform>
    {
        [SerializeField]
        private Vector3 scale = Vector3.one;
        
        [SerializeField] 
        private OverTimeHelper overTime;
        
        [NonSerialized] 
        private UnityEngine.Transform _transform;
        
        protected override void OnStart(in UnityEngine.Transform transform)
        {
            if (transform == null)
                throw new JungleException("Inputted Transform was null.");
            
            _transform = transform;
            
            if (!overTime.enabled)
            {
                _transform.localScale = scale;
                CallAndStop(_transform);
            }
        }
        
        protected override void OnUpdate()
        {
            if (_transform == null)
            {
                throw new JungleException
                (
                    "Failed to set scale because the transform is null." +
                    " Did you delete its Game Object?"
                );
            }
            
            if (_transform.localScale == scale)
            {
                CallAndStop(_transform);
                return;
            }
            _transform.localScale = overTime.SetVector3OverTime(_transform.localScale, scale);
        }
        
        public override string GetDetails()
        {
            return $"<b>{scale.ToString()}</b>";
        }
    }

#if UNITY_EDITOR
    [CustomEditor(typeof(SetScaleNode))]
    internal class SetScaleNodeEditor : UnityEditor.Editor
    {
        private SerializedProperty _scale;
        private SerializedProperty _overTime;

        private void OnEnable()
        {
            _scale = serializedObject.FindProperty("scale");
            _overTime = serializedObject.FindProperty("overTime");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_scale);
            EditorGUILayout.PropertyField(_overTime);
            
            serializedObject.ApplyModifiedProperties();
        }
    }
#endif
}

